Why is the ScoreBoard component displaying Invalid date?

Here is the current response from the live websocket:

```
[{"game_id":"0022400885","game_status":2,"away_team":{"team_id":"1610612744","team_name":"Warriors","team_city":"Golden State","team_tricode":"GSW","score":27},"home_team":{"team_id":"1610612752","team_name":"Knicks","team_city":"New York","team_tricode":"NYK","score":34},"period":2,"clock":"PT09M07.00S","game_time":"2025-03-05T00:30:00+00:00"},{"game_id":"0022400886","game_status":2,"away_team":{"team_id":"1610612739","team_name":"Cavaliers","team_city":"Cleveland","team_tricode":"CLE","score":0},"home_team":{"team_id":"1610612741","team_name":"Bulls","team_city":"Chicago","team_tricode":"CHI","score":0},"period":1,"clock":"PT11M37.00S","game_time":"2025-03-05T01:00:00+00:00"},{"game_id":"0022400884","game_status":2,"away_team":{"team_id":"1610612749","team_name":"Bucks","team_city":"Milwaukee","team_tricode":"MIL","score":39},"home_team":{"team_id":"1610612737","team_name":"Hawks","team_city":"Atlanta","team_tricode":"ATL","score":43},"period":2,"clock":"PT09M29.00S","game_time":"2025-03-05T00:30:00+00:00"},{"game_id":"0022400883","game_status":2,"away_team":{"team_id":"1610612761","team_name":"Raptors","team_city":"Toronto","team_tricode":"TOR","score":47},"home_team":{"team_id":"1610612753","team_name":"Magic","team_city":"Orlando","team_tricode":"ORL","score":48},"period":2,"clock":"PT00M46.80S","game_time":"2025-03-05T00:00:00+00:00"},{"game_id":"0022400882","game_status":2,"away_team":{"team_id":"1610612745","team_name":"Rockets","team_city":"Houston","team_tricode":"HOU","score":57},"home_team":{"team_id":"1610612754","team_name":"Pacers","team_city":"Indiana","team_tricode":"IND","score":67},"period":2,"clock":"PT00M00.00S","game_time":"2025-03-05T00:00:00+00:00"},{"game_id":"0022400887","game_status":1,"away_team":{"team_id":"1610612755","team_name":"76ers","team_city":"Philadelphia","team_tricode":"PHI","score":0},"home_team":{"team_id":"1610612750","team_name":"Timberwolves","team_city":"Minnesota","team_tricode":"MIN","score":0},"period":0,"clock":null,"game_time":"2025-03-05T01:00:00+00:00"},{"game_id":"0022400888","game_status":1,"away_team":{"team_id":"1610612751","team_name":"Nets","team_city":"Brooklyn","team_tricode":"BKN","score":0},"home_team":{"team_id":"1610612759","team_name":"Spurs","team_city":"San Antonio","team_tricode":"SAS","score":0},"period":0,"clock":null,"game_time":"2025-03-05T01:30:00+00:00"},{"game_id":"0022400889","game_status":1,"away_team":{"team_id":"1610612746","team_name":"Clippers","team_city":"LA","team_tricode":"LAC","score":0},"home_team":{"team_id":"1610612756","team_name":"Suns","team_city":"Phoenix","team_tricode":"PHX","score":0},"period":0,"clock":null,"game_time":"2025-03-05T03:00:00+00:00"},{"game_id":"0022400890","game_status":1,"away_team":{"team_id":"1610612740","team_name":"Pelicans","team_city":"New Orleans","team_tricode":"NOP","score":0},"home_team":{"team_id":"1610612747","team_name":"Lakers","team_city":"Los Angeles","team_tricode":"LAL","score":0},"period":0,"clock":null,"game_time":"2025-03-05T03:30:00+00:00"}]
```



Directory structure:
└── src/
    ├── App.css
    ├── App.jsx
    ├── ScoreBoardFix.txt
    ├── clade.txt
    ├── index.css
    ├── main.jsx
    ├── mobile.md
    ├── assets/
    │   └── nba_logos/
    │       └── teamLogosMap.js
    ├── components/
    │   ├── BoxScore.jsx
    │   ├── ConnectionIndicator.jsx
    │   ├── DateScoreBoard.jsx
    │   ├── GameDetailsModal.jsx
    │   ├── NBAPlayerStats.jsx
    │   ├── PlayByPlay.jsx
    │   ├── Scoreboard.jsx
    │   ├── Standings.jsx
    │   └── common/
    │       ├── GameCard.jsx
    │       ├── GameCategorySection.jsx
    │       ├── Header.jsx
    │       ├── TeamInfo.jsx
    │       └── player/
    │           ├── PlayerGameStats.jsx
    │           ├── PlayerHeader.jsx
    │           ├── PlayerSearch.jsx
    │           └── PlayerStatsTable.jsx
    ├── context/
    ├── hooks/
    │   └── useWebSocket.js
    ├── services/
    │   ├── apiService.js
    │   └── playerService.js
    ├── styles/
    │   ├── AG.css
    │   ├── tailwind.css
    │   └── theme.js
    ├── theme/
    │   └── theme.js
    └── utils/
        ├── dateUtils.js
        └── pastDateUtils.js

================================================
File: App.css
================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


================================================
File: App.jsx
================================================
import { ThemeProvider, createTheme } from "@mui/material/styles";
import CssBaseline from "@mui/material/CssBaseline";
import Tabs from "@mui/material/Tabs";
import Tab from "@mui/material/Tab";
import Box from "@mui/material/Box";
import CalendarTodayIcon from "@mui/icons-material/CalendarToday";
import SportsBasketballIcon from "@mui/icons-material/SportsBasketball";
import ScoreboardIcon from '@mui/icons-material/Scoreboard';
import LeaderboardIcon from '@mui/icons-material/Leaderboard';
import Scoreboard from "./components/Scoreboard";
import DateScoreBoard from "./components/DateScoreBoard";
import NBAPlayerStats from "./components/NBAPlayerStats";
import Standings from "./components/Standings";
import { useState } from "react";
import useWebSocket from "./hooks/useWebSocket";
import darkTheme from './styles/theme'
import useMediaQuery from "@mui/material/useMediaQuery";


// Custom TabPanel component to handle content display
function TabPanel({ children, value, index }) {
  if (value !== index) return null;
  return (
    <div
      role="tabpanel"
      id={`scoreboard-tabpanel-${index}`}
      aria-labelledby={`scoreboard-tab-${index}`}
      style={{ height: "100%" }}
    >
      <Box sx={{ p: { xs: 1, sm: 2, md: 3 }, height: "100%" }}>{children}</Box>
    </div>
  );
}

function App() {
  const [currentTab, setCurrentTab] = useState(1);
  const { games, isConnected, lastUpdateTime } = useWebSocket();
  const isMobile = useMediaQuery("(max-width:600px)");
  const isPortrait = useMediaQuery("(orientation: portrait)");

  const handleTabChange = (event, newValue) => {
    setCurrentTab(newValue);
  };

  return (
    <ThemeProvider theme={darkTheme}>
      <CssBaseline />
      <Box
        sx={{
          width: "100%",
          bgcolor: "background.paper",
          minHeight: "100vh",
          display: "flex",
          flexDirection: "column",
        }}
      >
        <Tabs
          value={currentTab}
          onChange={handleTabChange}
          centered={!isPortrait}
          variant={isPortrait ? "fullWidth" : "standard"}
          scrollButtons={isPortrait ? false : "auto"}
          allowScrollButtonsMobile
          aria-label="scoreboard navigation tabs"
          sx={{
            "& .MuiTab-root": {
              fontSize: isMobile && isPortrait ? "0.7rem" : undefined,
              minWidth: isMobile && isPortrait ? 0 : undefined,
              padding: isMobile && isPortrait ? "6px 4px" : undefined,
            },
          }}
        >
          <Tab
            icon={<CalendarTodayIcon fontSize={isMobile && isPortrait ? "small" : "medium"} />}
            label="Yesterday"
            id="scoreboard-tab-0"
            aria-controls="scoreboard-tabpanel-0"
          />
          <Tab
            icon={<ScoreboardIcon fontSize={isMobile && isPortrait ? "small" : "medium"} />}
            label="Live"
            id="scoreboard-tab-1"
            aria-controls="scoreboard-tabpanel-1"
          />
          <Tab
            icon={<SportsBasketballIcon fontSize={isMobile && isPortrait ? "small" : "medium"} />}
            label="NBA Stats"
            id="scoreboard-tab-2"
            aria-controls="scoreboard-tabpanel-2"
          />
          <Tab
            icon={<LeaderboardIcon fontSize={isMobile && isPortrait ? "small" : "medium"} />}
            label="Standings"
            id="scoreboard-tab-3"
            aria-controls="scoreboard-tabpanel-3"
          />
        </Tabs>
        <Box sx={{ flex: 1, display: "flex", flexDirection: "column" }}>
          <TabPanel value={currentTab} index={0}>
            <DateScoreBoard />
          </TabPanel>
          <TabPanel value={currentTab} index={1}>
            <Scoreboard
              games={games}
              isConnected={isConnected}
              lastUpdateTime={lastUpdateTime}
            />
          </TabPanel>
          <TabPanel value={currentTab} index={2}>
            <NBAPlayerStats />
          </TabPanel>
          <TabPanel value={currentTab} index={3}>
            <Standings />
          </TabPanel>
        </Box>
      </Box>
    </ThemeProvider>
  );
}

export default App;

================================================
File: ScoreBoardFix.txt
================================================
Examine the ScoreBoard component and how it handles displaying upcoming games. Currently, they are displayed as "invalid date". Perhaps the DateUtils component is handling this.




JSON
```
[
    {
        "away_team": {
            "score": 14,
            "team_city": "Golden State",
            "team_id": "1610612744",
            "team_name": "Warriors",
            "team_tricode": "GSW"
        },
        "clock": "PT06M48.00S",
        "game_id": "0022400885",
        "game_status": 2,
        "game_time": "2025-03-05T00:30:00+00:00",
        "home_team": {
            "score": 15,
            "team_city": "New York",
            "team_id": "1610612752",
            "team_name": "Knicks",
            "team_tricode": "NYK"
        },
        "period": 1
    },
    {
        "away_team": {
            "score": 8,
            "team_city": "Milwaukee",
            "team_id": "1610612749",
            "team_name": "Bucks",
            "team_tricode": "MIL"
        },
        "clock": "PT08M52.00S",
        "game_id": "0022400884",
        "game_status": 2,
        "game_time": "2025-03-05T00:30:00+00:00",
        "home_team": {
            "score": 5,
            "team_city": "Atlanta",
            "team_id": "1610612737",
            "team_name": "Hawks",
            "team_tricode": "ATL"
        },
        "period": 1
    },
    {
        "away_team": {
            "score": 22,
            "team_city": "Toronto",
            "team_id": "1610612761",
            "team_name": "Raptors",
            "team_tricode": "TOR"
        },
        "clock": "PT11M18.00S",
        "game_id": "0022400883",
        "game_status": 2,
        "game_time": "2025-03-05T00:00:00+00:00",
        "home_team": {
            "score": 22,
            "team_city": "Orlando",
            "team_id": "1610612753",
            "team_name": "Magic",
            "team_tricode": "ORL"
        },
        "period": 2
    },
    {
        "away_team": {
            "score": 37,
            "team_city": "Houston",
            "team_id": "1610612745",
            "team_name": "Rockets",
            "team_tricode": "HOU"
        },
        "clock": "PT09M14.00S",
        "game_id": "0022400882",
        "game_status": 2,
        "game_time": "2025-03-05T00:00:00+00:00",
        "home_team": {
            "score": 36,
            "team_city": "Indiana",
            "team_id": "1610612754",
            "team_name": "Pacers",
            "team_tricode": "IND"
        },
        "period": 2
    },
    {
        "away_team": {
            "score": 0,
            "team_city": "Cleveland",
            "team_id": "1610612739",
            "team_name": "Cavaliers",
            "team_tricode": "CLE"
        },
        "clock": null,
        "game_id": "0022400886",
        "game_status": 1,
        "game_time": "2025-03-05T01:00:00+00:00",
        "home_team": {
            "score": 0,
            "team_city": "Chicago",
            "team_id": "1610612741",
            "team_name": "Bulls",
            "team_tricode": "CHI"
        },
        "period": 0
    },
    {
        "away_team": {
            "score": 0,
            "team_city": "Philadelphia",
            "team_id": "1610612755",
            "team_name": "76ers",
            "team_tricode": "PHI"
        },
        "clock": null,
        "game_id": "0022400887",
        "game_status": 1,
        "game_time": "2025-03-05T01:00:00+00:00",
        "home_team": {
            "score": 0,
            "team_city": "Minnesota",
            "team_id": "1610612750",
            "team_name": "Timberwolves",
            "team_tricode": "MIN"
        },
        "period": 0
    },
    {
        "away_team": {
            "score": 0,
            "team_city": "Brooklyn",
            "team_id": "1610612751",
            "team_name": "Nets",
            "team_tricode": "BKN"
        },
        "clock": null,
        "game_id": "0022400888",
        "game_status": 1,
        "game_time": "2025-03-05T01:30:00+00:00",
        "home_team": {
            "score": 0,
            "team_city": "San Antonio",
            "team_id": "1610612759",
            "team_name": "Spurs",
            "team_tricode": "SAS"
        },
        "period": 0
    },
    {
        "away_team": {
            "score": 0,
            "team_city": "LA",
            "team_id": "1610612746",
            "team_name": "Clippers",
            "team_tricode": "LAC"
        },
        "clock": null,
        "game_id": "0022400889",
        "game_status": 1,
        "game_time": "2025-03-05T03:00:00+00:00",
        "home_team": {
            "score": 0,
            "team_city": "Phoenix",
            "team_id": "1610612756",
            "team_name": "Suns",
            "team_tricode": "PHX"
        },
        "period": 0
    },
    {
        "away_team": {
            "score": 0,
            "team_city": "New Orleans",
            "team_id": "1610612740",
            "team_name": "Pelicans",
            "team_tricode": "NOP"
        },
        "clock": null,
        "game_id": "0022400890",
        "game_status": 1,
        "game_time": "2025-03-05T03:30:00+00:00",
        "home_team": {
            "score": 0,
            "team_city": "Los Angeles",
            "team_id": "1610612747",
            "team_name": "Lakers",
            "team_tricode": "LAL"
        },
        "period": 0
    }
]
```

================================================
File: clade.txt
================================================
Why is the ScoreBoard component displaying Invalid date?

Here is the current response from the live websocket:

```
[{"game_id":"0022400885","game_status":2,"away_team":{"team_id":"1610612744","team_name":"Warriors","team_city":"Golden State","team_tricode":"GSW","score":27},"home_team":{"team_id":"1610612752","team_name":"Knicks","team_city":"New York","team_tricode":"NYK","score":34},"period":2,"clock":"PT09M07.00S","game_time":"2025-03-05T00:30:00+00:00"},{"game_id":"0022400886","game_status":2,"away_team":{"team_id":"1610612739","team_name":"Cavaliers","team_city":"Cleveland","team_tricode":"CLE","score":0},"home_team":{"team_id":"1610612741","team_name":"Bulls","team_city":"Chicago","team_tricode":"CHI","score":0},"period":1,"clock":"PT11M37.00S","game_time":"2025-03-05T01:00:00+00:00"},{"game_id":"0022400884","game_status":2,"away_team":{"team_id":"1610612749","team_name":"Bucks","team_city":"Milwaukee","team_tricode":"MIL","score":39},"home_team":{"team_id":"1610612737","team_name":"Hawks","team_city":"Atlanta","team_tricode":"ATL","score":43},"period":2,"clock":"PT09M29.00S","game_time":"2025-03-05T00:30:00+00:00"},{"game_id":"0022400883","game_status":2,"away_team":{"team_id":"1610612761","team_name":"Raptors","team_city":"Toronto","team_tricode":"TOR","score":47},"home_team":{"team_id":"1610612753","team_name":"Magic","team_city":"Orlando","team_tricode":"ORL","score":48},"period":2,"clock":"PT00M46.80S","game_time":"2025-03-05T00:00:00+00:00"},{"game_id":"0022400882","game_status":2,"away_team":{"team_id":"1610612745","team_name":"Rockets","team_city":"Houston","team_tricode":"HOU","score":57},"home_team":{"team_id":"1610612754","team_name":"Pacers","team_city":"Indiana","team_tricode":"IND","score":67},"period":2,"clock":"PT00M00.00S","game_time":"2025-03-05T00:00:00+00:00"},{"game_id":"0022400887","game_status":1,"away_team":{"team_id":"1610612755","team_name":"76ers","team_city":"Philadelphia","team_tricode":"PHI","score":0},"home_team":{"team_id":"1610612750","team_name":"Timberwolves","team_city":"Minnesota","team_tricode":"MIN","score":0},"period":0,"clock":null,"game_time":"2025-03-05T01:00:00+00:00"},{"game_id":"0022400888","game_status":1,"away_team":{"team_id":"1610612751","team_name":"Nets","team_city":"Brooklyn","team_tricode":"BKN","score":0},"home_team":{"team_id":"1610612759","team_name":"Spurs","team_city":"San Antonio","team_tricode":"SAS","score":0},"period":0,"clock":null,"game_time":"2025-03-05T01:30:00+00:00"},{"game_id":"0022400889","game_status":1,"away_team":{"team_id":"1610612746","team_name":"Clippers","team_city":"LA","team_tricode":"LAC","score":0},"home_team":{"team_id":"1610612756","team_name":"Suns","team_city":"Phoenix","team_tricode":"PHX","score":0},"period":0,"clock":null,"game_time":"2025-03-05T03:00:00+00:00"},{"game_id":"0022400890","game_status":1,"away_team":{"team_id":"1610612740","team_name":"Pelicans","team_city":"New Orleans","team_tricode":"NOP","score":0},"home_team":{"team_id":"1610612747","team_name":"Lakers","team_city":"Los Angeles","team_tricode":"LAL","score":0},"period":0,"clock":null,"game_time":"2025-03-05T03:30:00+00:00"}]
```

================================================
File: index.css
================================================
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}


================================================
File: main.jsx
================================================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.jsx'
import { ThemeProvider } from '@mui/material/styles'
import CssBaseline from '@mui/material/CssBaseline'
import { theme } from './theme/theme'
import './styles/tailwind.css';

ReactDOM.createRoot(document.getElementById('root')).render(
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <App />
    </ThemeProvider>
)

================================================
File: mobile.md
================================================
Lets work on making the component code in here mobile friendly and responsive. The first mobile size I want to focus on is the Iphone Pro Max sizes (430x932). Currently, the tabs in App.jsx are overflowing. In addition, the BoxScore component looks too compressed on screen. Lets focus on these two areas first.

================================================
File: assets/nba_logos/teamLogosMap.js
================================================
// Import all logos
import ATL from "./ATL.svg";
import BOS from "./BOS.svg";
import BKN from "./BKN.svg";
import CHA from "./CHA.svg";
import CHI from "./CHI.svg";
import CLE from "./CLE.svg";
import DAL from "./DAL.svg";
import DEN from "./DEN.svg";
import DET from "./DET.svg";
import GSW from "./GSW.svg";
import HOU from "./HOU.svg";
import IND from "./IND.svg";
import LAC from "./LAC.svg";
import LAL from "./LAL.svg";
import MEM from "./MEM.svg";
import MIA from "./MIA.svg";
import MIL from "./MIL.svg";
import MIN from "./MIN.svg";
import NOP from "./NOP.svg";
import NYK from "./NYK.svg";
import OKC from "./OKC.svg";
import ORL from "./ORL.svg";
import PHI from "./PHI.svg";
import PHX from "./PHX.svg";
import POR from "./POR.svg";
import SAC from "./SAC.svg";
import SAS from "./SAS.svg";
import TOR from "./TOR.svg";
import UTA from "./UTA.svg";
import WAS from "./WAS.svg";

export const teamLogos = {
  ATL,
  BOS,
  BKN,
  CHA,
  CHI,
  CLE,
  DAL,
  DEN,
  DET,
  GSW,
  HOU,
  IND,
  LAC,
  LAL,
  MEM,
  MIA,
  MIL,
  MIN,
  NOP,
  NYK,
  OKC,
  ORL,
  PHI,
  PHX,
  POR,
  SAC,
  SAS,
  TOR,
  UTA,
  WAS,
};

================================================
File: components/BoxScore.jsx
================================================
import React, { useState, useEffect } from "react";
import PropTypes from "prop-types";
import {
  Box,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TableSortLabel,
  Toolbar,
  Typography,
  CircularProgress,
  useMediaQuery,
  Button,
  Collapse,
} from "@mui/material";
import { visuallyHidden } from "@mui/utils";
import { teamLogos } from "../assets/nba_logos/teamLogosMap";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import ExpandLessIcon from "@mui/icons-material/ExpandLess";

const getTeamAbbreviation = (teamCity, teamName) => {
  const teamAbbreviations = {
    Atlanta: "ATL",
    Boston: "BOS",
    Brooklyn: "BKN",
    Charlotte: "CHA",
    Chicago: "CHI",
    Cleveland: "CLE",
    Dallas: "DAL",
    Denver: "DEN",
    Detroit: "DET",
    "Golden State": "GSW",
    Houston: "HOU",
    Indiana: "IND",
    LA: "LAC",
    "Los Angeles": "LAL",
    Memphis: "MEM",
    Miami: "MIA",
    Milwaukee: "MIL",
    Minnesota: "MIN",
    "New Orleans": "NOP",
    "New York": "NYK",
    "Oklahoma City": "OKC",
    Orlando: "ORL",
    Philadelphia: "PHI",
    Phoenix: "PHX",
    Portland: "POR",
    Sacramento: "SAC",
    "San Antonio": "SAS",
    Toronto: "TOR",
    Utah: "UTA",
    Washington: "WAS",
  };
  return teamAbbreviations[teamCity] || "";
};

const headCells = [
  { id: "name", numeric: false, label: "PLAYER", width: "18%" },
  { id: "minutes", numeric: false, label: "MIN", width: "10%" },
  { id: "points", numeric: true, label: "PTS", width: "10%" },
  { id: "reboundsTotal", numeric: true, label: "REB", width: "10%" },
  { id: "assists", numeric: true, label: "AST", width: "10%" },
  { id: "fieldGoals", numeric: true, label: "FG", width: "15%" },
  { id: "threePointers", numeric: true, label: "3P", width: "15%" },
  { id: "plusMinusPoints", numeric: true, label: "+/-", width: "12%" },
];

const formatPlayerName = (fullName, isMobile, isXsScreen) => {
  if (!isMobile) return fullName;
  
  const nameParts = fullName.split(" ");
  if (nameParts.length < 2) return fullName;
  
  const firstName = nameParts[0];
  const lastName = nameParts.slice(1).join(" ");
  
  if (isXsScreen) {
    // First initial + last name, truncated if needed
    return `${firstName[0]}. ${lastName.length > 6 ? lastName.substring(0, 6) + "." : lastName}`;
  }
  
  return `${firstName[0]}. ${lastName}`;
};

function descendingComparator(a, b, orderBy) {
  if (orderBy === "fieldGoals") {
    const aMade = a.statistics.fieldGoalsMade ?? 0;
    const bMade = b.statistics.fieldGoalsMade ?? 0;
    if (bMade !== aMade) return bMade - aMade;
    return (
      (b.statistics.fieldGoalsAttempted ?? 0) -
      (a.statistics.fieldGoalsAttempted ?? 0)
    );
  }
  if (orderBy === "threePointers") {
    const aMade = a.statistics.threePointersMade ?? 0;
    const bMade = b.statistics.threePointersMade ?? 0;
    if (bMade !== aMade) return bMade - aMade;
    return (
      (b.statistics.threePointersAttempted ?? 0) -
      (a.statistics.threePointersAttempted ?? 0)
    );
  }
  if (orderBy === "minutes") {
    const aMinutes = a.statistics.minutes.match(/PT(\d+)M/)
      ? parseInt(a.statistics.minutes.match(/PT(\d+)M/)[1])
      : 0;
    const bMinutes = b.statistics.minutes.match(/PT(\d+)M/)
      ? parseInt(b.statistics.minutes.match(/PT(\d+)M/)[1])
      : 0;
    return bMinutes - aMinutes;
  }

  const aValue = orderBy === "name" ? a[orderBy] : a.statistics[orderBy] ?? 0;
  const bValue = orderBy === "name" ? b[orderBy] : b.statistics[orderBy] ?? 0;

  if (bValue < aValue) return -1;
  if (bValue > aValue) return 1;
  return 0;
}

function getComparator(order, orderBy) {
  return order === "desc"
    ? (a, b) => descendingComparator(a, b, orderBy)
    : (a, b) => -descendingComparator(a, b, orderBy);
}

function EnhancedTableHead(props) {
  const { order, orderBy, onRequestSort, isMobile, isXsScreen } = props;
  const createSortHandler = (property) => (event) => {
    onRequestSort(event, property);
  };

  return (
    <TableHead>
      <TableRow>
        {headCells.map((headCell) => (
          <TableCell
            key={headCell.id}
            align={headCell.numeric ? "right" : "left"}
            sortDirection={orderBy === headCell.id ? order : false}
            sx={{
              backgroundColor: "#101010",
              color: "rgba(255, 255, 255, 0.95)",
              fontWeight: 600,
              width: headCell.width,
              padding: isXsScreen 
                ? headCell.id === "name" || headCell.id === "plusMinusPoints" 
                  ? "4px 4px" 
                  : "4px 1px" 
                : isMobile 
                  ? headCell.id === "name" || headCell.id === "plusMinusPoints"
                    ? "6px 6px"
                    : "6px 2px" 
                  : "12px 16px",
              fontSize: isXsScreen ? "0.6rem" : isMobile ? "0.7rem" : "0.875rem",
              borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
              whiteSpace: "nowrap",
            }}
          >
            <TableSortLabel
              active={orderBy === headCell.id}
              direction={orderBy === headCell.id ? order : "desc"}
              onClick={createSortHandler(headCell.id)}
              sx={{
                color: "rgba(255, 255, 255, 0.95) !important",
                "&.Mui-active": {
                  color: "#64b5f6 !important",
                },
                "& .MuiTableSortLabel-icon": {
                  color: "#64b5f6 !important",
                },
              }}
            >
              {headCell.label}
              {orderBy === headCell.id ? (
                <Box component="span" sx={visuallyHidden}>
                  {order === "desc" ? "sorted descending" : "sorted ascending"}
                </Box>
              ) : null}
            </TableSortLabel>
          </TableCell>
        ))}
      </TableRow>
    </TableHead>
  );
}

function formatMinutes(minutes) {
  if (!minutes || minutes === "PT00M00.00S") return "0:00";
  const match = minutes.match(/PT(\d+)M(\d+\.\d+)S/);
  if (!match) return minutes;
  return `${match[1]}:${Math.floor(parseFloat(match[2]))
    .toString()
    .padStart(2, "0")}`;
}

function formatFractionalStat(made, attempted, isMobile, isXsScreen) {
  if (isXsScreen) {
    return `${made}-${attempted}`;
  }
  return `${made}-${attempted}`;
}

function TeamBoxScoreTable({ team, teamName, scoreboardScore }) {
  const isMobile = useMediaQuery("(max-width:600px)");
  const isXsScreen = useMediaQuery("(max-width:430px)");
  const isPortrait = useMediaQuery("(orientation: portrait)");
  const [order, setOrder] = useState("desc");
  const [orderBy, setOrderBy] = useState("minutes");
  const [showAll, setShowAll] = useState(false);

  const handleRequestSort = (event, property) => {
    const isAsc = orderBy === property && order === "desc";
    setOrder(isAsc ? "asc" : "desc");
    setOrderBy(property);
  };

  const activePlayers = team.players.filter(
    (player) => player.status === "ACTIVE"
  );

  const sortedPlayers = React.useMemo(
    () => [...activePlayers].sort(getComparator(order, orderBy)),
    [activePlayers, order, orderBy]
  );

  const displayedPlayers = showAll
    ? sortedPlayers
    : sortedPlayers.slice(0, isXsScreen ? 5 : isMobile ? 5 : 8);

  const teamAbbreviation = getTeamAbbreviation(team.teamCity, team.teamName);

  return (
    <Box sx={{ width: "100%", mb: 2 }}>
      <Paper
        sx={{
          width: "100%",
          mb: 2,
          backgroundColor: "#101010",
          borderRadius: "12px",
          border: "1px solid rgba(255, 255, 255, 0.08)",
          boxShadow: "0 4px 20px rgba(0, 0, 0, 0.4)",
          overflow: "hidden",
        }}
      >
        <Toolbar
          sx={{
            pl: isXsScreen ? 1 : isMobile ? 1.5 : 3,
            pr: isXsScreen ? 0.5 : isMobile ? 1 : 2,
            minHeight: isXsScreen ? "44px" : isMobile ? "50px" : "72px",
            display: "flex",
            alignItems: "center",
            gap: isXsScreen ? 0.5 : 1,
            borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
            backgroundColor: "#101010",
          }}
        >
          <Box
            component="img"
            src={teamLogos[teamAbbreviation]}
            alt={`${team.teamCity} ${team.teamName} logo`}
            sx={{
              height: isXsScreen ? "24px" : isMobile ? "28px" : "40px",
              width: "auto",
              objectFit: "contain",
            }}
          />
          <Typography
            sx={{
              flex: "1 1 100%",
              fontSize: isXsScreen ? "0.8rem" : isMobile ? "0.9rem" : "1.25rem",
              fontWeight: 600,
              color: "white",
              whiteSpace: "nowrap",
              overflow: "hidden",
              textOverflow: "ellipsis",
            }}
            variant="h6"
            component="div"
          >
            {isXsScreen ? team.teamName : teamName}
            {scoreboardScore && (
              <Typography
                component="span"
                sx={{
                  ml: isXsScreen ? 1.5 : isMobile ? 2 : 3,
                  color: "#64b5f6",
                  fontSize: isXsScreen ? "0.9rem" : isMobile ? "1rem" : "1.5rem",
                  fontWeight: 600,
                }}
              >
                {scoreboardScore}
              </Typography>
            )}
          </Typography>
        </Toolbar>

        <TableContainer>
          <Table
            size={isXsScreen ? "small" : isMobile ? "small" : "medium"}
            sx={{
              tableLayout: "fixed",
              "& .MuiTableCell-root": {
                padding: isXsScreen ? "4px 1px" : isMobile ? "6px 2px" : "12px 16px",
                fontSize: isXsScreen ? "0.65rem" : isMobile ? "0.7rem" : "0.875rem",
                color: "rgba(255, 255, 255, 0.95)",
                borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
              },
              "& .MuiTableRow-root:hover": {
                backgroundColor: "rgba(255, 255, 255, 0.03)",
              },
            }}
          >
            <colgroup>
              {headCells.map((cell, index) => (
                <col key={index} style={{ width: cell.width }} />
              ))}
            </colgroup>

            <EnhancedTableHead
              order={order}
              orderBy={orderBy}
              onRequestSort={handleRequestSort}
              isMobile={isMobile}
              isXsScreen={isXsScreen}
            />
            <TableBody>
              {displayedPlayers.map((player, index) => (
                <TableRow
                  hover
                  tabIndex={-1}
                  key={player.name}
                  sx={{
                    backgroundColor: player.starter
                      ? "rgba(255, 255, 255, 0.00)"
                      : index % 2 === 0
                      ? "rgba(255, 255, 255, 0.00)"
                      : "transparent",
                    "&:hover": {
                      backgroundColor: "rgba(255, 255, 255, 0.06) !important",
                    },
                  }}
                >
                  <TableCell
                    sx={{
                      color: "rgba(255, 255, 255, 0.9)",
                      fontWeight: player.starter ? 600 : 400,
                      position: "relative",
                      display: "flex",
                      alignItems: "center",
                      gap: isXsScreen ? "2px" : "4px",
                      padding: isXsScreen ? "4px 4px" : isMobile ? "6px 6px" : "12px 16px",
                    }}
                  >
                    {formatPlayerName(player.name, isMobile, isXsScreen)}
                    {player.oncourt && (
                      <Box
                        sx={{
                          width: "5px",
                          height: "5px",
                          borderRadius: "50%",
                          backgroundColor: "#4caf50",
                          display: "inline-block",
                          animation: "pulse 2s infinite",
                        }}
                      />
                    )}
                  </TableCell>
                  <TableCell sx={{ padding: isXsScreen ? "4px 1px" : isMobile ? "6px 2px" : "12px 16px" }}>
                    {formatMinutes(player.statistics.minutes)}
                  </TableCell>
                  <TableCell
                    align="right"
                    sx={{
                      color:
                        player.statistics.points >= 20 ? "#64b5f6" : "inherit",
                      fontWeight: player.statistics.points >= 20 ? 600 : 400,
                      padding: isXsScreen ? "4px 1px" : isMobile ? "6px 2px" : "12px 16px",
                    }}
                  >
                    {player.statistics.points}
                  </TableCell>
                  <TableCell
                    align="right"
                    sx={{
                      color:
                        player.statistics.reboundsTotal >= 10
                          ? "#64b5f6"
                          : "inherit",
                      fontWeight:
                        player.statistics.reboundsTotal >= 10 ? 600 : 400,
                      padding: isXsScreen ? "4px 1px" : isMobile ? "6px 2px" : "12px 16px",
                    }}
                  >
                    {player.statistics.reboundsTotal}
                  </TableCell>
                  <TableCell
                    align="right"
                    sx={{
                      color:
                        player.statistics.assists >= 10 ? "#64b5f6" : "inherit",
                      fontWeight: player.statistics.assists >= 10 ? 600 : 400,
                      padding: isXsScreen ? "4px 1px" : isMobile ? "6px 2px" : "12px 16px",
                    }}
                  >
                    {player.statistics.assists}
                  </TableCell>
                  <TableCell 
                    align="right"
                    sx={{ padding: isXsScreen ? "4px 1px" : isMobile ? "6px 2px" : "12px 16px" }}
                  >
                    {formatFractionalStat(
                      player.statistics.fieldGoalsMade,
                      player.statistics.fieldGoalsAttempted,
                      isMobile,
                      isXsScreen
                    )}
                  </TableCell>
                  <TableCell 
                    align="right"
                    sx={{ padding: isXsScreen ? "4px 1px" : isMobile ? "6px 2px" : "12px 16px" }}
                  >
                    {formatFractionalStat(
                      player.statistics.threePointersMade,
                      player.statistics.threePointersAttempted,
                      isMobile,
                      isXsScreen
                    )}
                  </TableCell>
                  <TableCell
                    align="right"
                    sx={{
                      color:
                        player.statistics.plusMinusPoints > 0
                          ? "#4caf50"
                          : player.statistics.plusMinusPoints < 0
                          ? "#f44336"
                          : "inherit",
                      fontWeight:
                        Math.abs(player.statistics.plusMinusPoints) >= 15
                          ? 600
                          : 400,
                      padding: isXsScreen ? "4px 4px" : isMobile ? "6px 6px" : "12px 16px",
                    }}
                  >
                    {player.statistics.plusMinusPoints > 0
                      ? `+${player.statistics.plusMinusPoints}`
                      : player.statistics.plusMinusPoints}
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>

        {/* Expand/Collapse Button */}
        {activePlayers.length > (isXsScreen ? 5 : isMobile ? 5 : 8) && (
          <Box
            sx={{
              display: "flex",
              justifyContent: "center",
              padding: isXsScreen ? 0.5 : isMobile ? 1 : 2,
              borderTop: "1px solid rgba(255, 255, 255, 0.08)",
              backgroundColor: "#101010",
            }}
          >
            <Button
              onClick={() => setShowAll(!showAll)}
              endIcon={showAll ? <ExpandLessIcon /> : <ExpandMoreIcon />}
              sx={{
                color: "#64b5f6",
                "&:hover": {
                  backgroundColor: "rgba(100, 181, 246, 0.08)",
                },
                textTransform: "none",
                fontWeight: 600,
                fontSize: isXsScreen ? "0.7rem" : undefined,
                padding: isXsScreen ? "2px 6px" : undefined,
              }}
            >
              {showAll ? "Show Less" : "Show All"}
            </Button>
          </Box>
        )}
      </Paper>
    </Box>
  );
}

const BoxScore = ({ game, open }) => {
  if (!game || !open) {
    return null;
  }

  const isMobile = useMediaQuery("(max-width:600px)");
  const isXsScreen = useMediaQuery("(max-width:430px)");
  const [boxScore, setBoxScore] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const api_url = import.meta.env.VITE_BACKEND_URL || "http://localhost:8000/api/v1";
  const gameId = game.gameId;
  const [awayScore, homeScore] = game.score
    .split(" - ")
    .map((score) => parseInt(score) || 0);

  useEffect(() => {
    const fetchBoxScore = async () => {
      if (!gameId) return;
      try {
        setLoading(true);
        const response = await fetch(`${api_url}/boxscore/${gameId}`);
        const data = await response.json();
        setBoxScore(data);
      } catch (err) {
        setError("Failed to load box score data");
        console.error("Error fetching box score:", err);
      } finally {
        setLoading(false);
      }
    };
    fetchBoxScore();
  }, [gameId]);

  return (
    <Box
      sx={{
        width: "100%",
        py: isXsScreen ? 0.5 : isMobile ? 1 : 2,
        px: isXsScreen ? 0.5 : isMobile ? 1 : 3,
        backgroundColor: "#101010",
        overflow: "auto",
        height: "100%",
        display: "flex",
        flexDirection: "column",
        "&::-webkit-scrollbar": {
          display: "none",
        },
        msOverflowStyle: "none",
        scrollbarWidth: "none",
      }}
    >
      {loading ? (
        <Box
          display="flex"
          justifyContent="center"
          alignItems="center"
          height="200px"
        >
          <CircularProgress sx={{ color: "#64b5f6" }} />
        </Box>
      ) : error ? (
        <Typography color="error" sx={{ textAlign: "center" }}>
          {error}
        </Typography>
      ) : (
        boxScore && (
          <>
            <TeamBoxScoreTable
              team={boxScore.away_team}
              teamName={`${boxScore.away_team.teamCity} ${boxScore.away_team.teamName}`}
              scoreboardScore={awayScore}
            />
            <TeamBoxScoreTable
              team={boxScore.home_team}
              teamName={`${boxScore.home_team.teamCity} ${boxScore.home_team.teamName}`}
              scoreboardScore={homeScore}
            />
          </>
        )
      )}
    </Box>
  );
};

BoxScore.propTypes = {
  game: PropTypes.object,
  open: PropTypes.bool,
};

export default BoxScore;

================================================
File: components/ConnectionIndicator.jsx
================================================
import React from "react";
import { Box } from "@mui/material";

const ConnectionIndicator = ({ connected }) => (
  <Box
    component="span"
    sx={{
      width: 8,
      height: 8,
      borderRadius: "50%",
      backgroundColor: connected ? "#4caf50" : "#f44336", // green when connected, red when disconnected
      display: "inline-block",
      mr: 1,
      "@keyframes pulse": {
        "0%": {
          transform: "scale(0.95)",
          boxShadow: "0 0 0 0 rgba(76, 175, 80, 0.7)",
        },
        "70%": {
          transform: "scale(1)",
          boxShadow: "0 0 0 6px rgba(76, 175, 80, 0)",
        },
        "100%": {
          transform: "scale(0.95)",
          boxShadow: "0 0 0 0 rgba(76, 175, 80, 0)",
        },
      },
      animation: connected ? "pulse 2s infinite" : "none",
    }}
  />
);

export default ConnectionIndicator;


================================================
File: components/DateScoreBoard.jsx
================================================
// DateScoreBoard.jsx
import React, { useState, useEffect } from "react";
import { Box, Container, Typography, useMediaQuery } from "@mui/material";
import { LocalizationProvider, DatePicker } from "@mui/x-date-pickers";
import { AdapterDayjs } from "@mui/x-date-pickers/AdapterDayjs";
import dayjs from "dayjs";
import GameDetailsModal from "./GameDetailsModal";
import GameCategorySection from "./common/GameCategorySection";
import Header from "./common/Header";
import { categorizeGames } from "../utils/dateUtils"; // Use dateUtils instead of pastDateUtils
import { fetchHistoricalGames } from "../services/apiService";

/**
 * Simple helper to transform the raw game data returned by the new endpoint
 * into the shape our UI expects (same as the "old" format).
 */
function transformGames(rawGames) {
  return rawGames.map((g) => {
    const awayScore = g.away_team?.score ?? 0;
    const homeScore = g.home_team?.score ?? 0;
    return {
      // Match the property names used in the UI
      gameId: g.game_id, // was "game_id" in the new data
      away_team: g.away_team?.team_name || "",
      away_tricode: g.away_team?.team_tricode || "",
      home_team: g.home_team?.team_name || "",
      home_tricode: g.home_team?.team_tricode || "",
      score: `${awayScore} - ${homeScore}`,
      // "clock" is already "Final" or similar, so we can store that in the "time" field
      time: g.clock || "",
    };
  });
}

/**
 * Date selector component with custom styling
 */
const DateSelector = ({ selectedDate, onDateChange }) => {
  return (
    <LocalizationProvider dateAdapter={AdapterDayjs}>
      <DatePicker
        label="Select Date"
        value={selectedDate}
        onChange={onDateChange}
        sx={{
          bgcolor: "background.paper",
          borderRadius: 1,
          "& .MuiOutlinedInput-root": {
            backgroundColor: "#262626",
            color: "white",
            "&:hover": {
              backgroundColor: "#2d2d2d",
            },
            "& fieldset": {
              borderColor: "rgba(255, 255, 255, 0.08)",
            },
            "&:hover fieldset": {
              borderColor: "rgba(255, 255, 255, 0.2)",
            },
            "&.Mui-focused fieldset": {
              borderColor: "#64b5f6",
            },
          },
          "& .MuiInputLabel-root": {
            color: "rgba(255, 255, 255, 0.7)",
            "&.Mui-focused": {
              color: "#64b5f6",
            },
          },
        }}
        // Disable future dates
        maxDate={dayjs().endOf('day')}
        disableFuture={true}
      />
    </LocalizationProvider>
  );
};

/**
 * Main DateScoreBoard component for displaying historical games by date
 */
const DateScoreBoard = () => {
  const isMobile = useMediaQuery("(max-width:600px)");
  const [games, setGames] = useState([]);
  const [selectedGame, setSelectedGame] = useState(null);
  const [boxScoreOpen, setBoxScoreOpen] = useState(false);
  const [showCompletedGames, setShowCompletedGames] = useState(true);

  // Default date is yesterday
  const [selectedDate, setSelectedDate] = useState(dayjs().subtract(1, "day"));

  /**
   * Fetch games data when date changes
   */
  useEffect(() => {
    console.log("Date changed in useEffect:", selectedDate.format("YYYY-MM-DD"));
    
    const loadGames = async () => {
      try {
        console.log("Starting to fetch games for date:", selectedDate.format("YYYY-MM-DD"));
        
        // Fetch the new raw data
        const rawGames = await fetchHistoricalGames(selectedDate);
        
        // Check if we have data
        if (!rawGames || rawGames.length === 0) {
          console.log("No games found for the selected date");
          setGames([]);
          return;
        }

        console.log("Raw games data:", rawGames);
        
        // Transform so our UI code can handle it
        const transformed = transformGames(rawGames);
        console.log("Transformed games:", transformed);
        
        // Apply time conversion if needed
        const processedGames = transformed.map(game => {
          // Convert game time to local time if needed
          if (game.time && game.time.startsWith("Start:")) {
            // Use the imported function from dateUtils
            return {
              ...game,
              time: game.time // Already in the right format
            };
          }
          return game;
        });
        
        setGames(processedGames);
      } catch (error) {
        console.error("Error fetching historical games:", error);
      }
    };

    loadGames();
  }, [selectedDate]);

  // Date change handler
  const handleDateChange = (newDate) => {
    console.log("Date changed to:", newDate.format("YYYY-MM-DD"));
    setSelectedDate(newDate);
  };

  // Categorize games into live, scheduled, and completed
  const { liveGames, scheduledGames, completedGames } = categorizeGames(games);

  // Click handler for an in-progress or completed game => open modal
  const handleBoxScoreClick = (game) => {
    console.log("Selected game for box score:", game);
    setSelectedGame(game);
    setBoxScoreOpen(true);
  };

  return (
    <Container
      maxWidth="xl"
      sx={{
        py: isMobile ? 2 : 4,
        px: isMobile ? 1 : 2,
        height: "100%",
        display: "flex",
        flexDirection: "column",
        maxWidth: "1400px !important",
      }}
    >
      {/* Header */}
      <Header
        title="Box Scores"
      />
      
      {/* Date Picker - Moved to a more user-friendly location */}
      <Box 
        sx={{ 
          mb: isMobile ? 3 : 4,
          display: "flex",
          justifyContent: "flex-start",
          mt: 2
        }}
      >
        <DateSelector
          selectedDate={selectedDate}
          onDateChange={handleDateChange}
        />
      </Box>

      {/* Game Sections */}
      {liveGames.length > 0 && (
        <GameCategorySection 
          games={liveGames} 
          title="Live Games" 
          onBoxScoreClick={handleBoxScoreClick} 
          isLive
        />
      )}
      
      {scheduledGames.length > 0 && (
        <GameCategorySection 
          games={scheduledGames} 
          title="Upcoming Games" 
          onBoxScoreClick={handleBoxScoreClick}
        />
      )}
      
      {completedGames.length > 0 && (
        <GameCategorySection 
          games={completedGames} 
          title="Completed Games" 
          onBoxScoreClick={handleBoxScoreClick}
          collapsible
          expanded={showCompletedGames}
          onToggleExpand={() => setShowCompletedGames(!showCompletedGames)}
        />
      )}

      {/* Game Details Modal */}
      <GameDetailsModal
        gameId={selectedGame}
        open={boxScoreOpen}
        onClose={() => {
          setBoxScoreOpen(false);
          setSelectedGame(null);
        }}
      />

      {/* Empty State */}
      {games.length === 0 && (
        <Box
          sx={{
            textAlign: "center",
            py: isMobile ? 4 : 6,
            opacity: 0.7,
          }}
        >
          <Typography
            variant={isMobile ? "body1" : "h6"}
            sx={{
              fontSize: isMobile ? "0.875rem" : "1rem",
            }}
          >
            No games scheduled for this date
          </Typography>
        </Box>
      )}
    </Container>
  );
};

export default DateScoreBoard;

================================================
File: components/GameDetailsModal.jsx
================================================
import React, { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogTitle,
  IconButton,
  Box,
  Tabs,
  Tab,
  useMediaQuery,
} from "@mui/material";
import { Close } from "@mui/icons-material";

import BoxScore from "./BoxScore";
import PlayByPlay from "./PlayByPlay";


const GameDetailsModal = ({ gameId, open, onClose }) => {
  const [activeTab, setActiveTab] = useState(0);
  const isMobile = useMediaQuery("(max-width:600px)");
  const isXsScreen = useMediaQuery("(max-width:430px)");
  const isPortrait = useMediaQuery("(orientation: portrait)");

  const game_id = gameId?.gameId;

  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };

  const resetTab = () => {
    onClose();
    setActiveTab(0);
  };

  // Calculate modal size for mobile devices
  const getModalSize = () => {
    if (!isMobile) {
      return {
        maxWidth: "xl",
        fullWidth: true,
        fullScreen: false,
        height: "90vh",
        width: "90%",
        maxHeight: "90vh",
      };
    }
    
    // Mobile in portrait mode
    if (isPortrait) {
      return {
        maxWidth: "sm",
        fullWidth: true,
        fullScreen: false,
        height: "80vh",
        width: "95%",
        maxHeight: "80vh",
        top: "10vh",
      };
    }
    
    // Mobile in landscape mode
    return {
      maxWidth: "xl",
      fullWidth: true,
      fullScreen: false,
      height: "90vh",
      width: "90%",
      maxHeight: "90vh",
    };
  };

  const modalSize = getModalSize();

  return (
    <Dialog
      open={open}
      onClose={resetTab}
      maxWidth={modalSize.maxWidth}
      fullWidth={modalSize.fullWidth}
      fullScreen={modalSize.fullScreen}
      PaperProps={{
        sx: {
          height: modalSize.height,
          width: modalSize.width,
          maxHeight: modalSize.maxHeight,
          backgroundColor: "#101010",
          display: "flex",
          flexDirection: "column",
          overflow: "hidden",
          borderRadius: "12px",
          border: "1px solid rgba(255, 255, 255, 0.08)",
          boxShadow: "0 4px 20px rgba(0, 0, 0, 0.4)",
          margin: "0 auto",
          ...(isPortrait && isMobile ? { 
            position: "absolute",
            top: modalSize.top,
          } : {}),
        },
      }}
    >
      {/* Header */}
      <Box
        sx={{
          borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
          backgroundColor: "#101010",
          zIndex: 1,
        }}
      >
        <DialogTitle
          sx={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            color: "white",
            padding: isXsScreen ? "8px 12px" : isMobile ? "12px 16px" : "16px 24px",
            fontSize: isXsScreen ? "1rem" : isMobile ? "1.1rem" : "1.25rem",
            minHeight: "auto",
            fontWeight: 600,
          }}
        >
          Game Details
          <IconButton
            onClick={resetTab}
            sx={{
              color: "white",
              padding: isXsScreen ? "6px" : isMobile ? "8px" : "12px",
              "&:hover": {
                backgroundColor: "rgba(255, 255, 255, 0.1)",
              },
            }}
          >
            <Close sx={{ fontSize: isXsScreen ? "1.1rem" : isMobile ? "1.25rem" : "1.5rem" }} />
          </IconButton>
        </DialogTitle>

        <Tabs
          value={activeTab}
          onChange={handleTabChange}
          textColor="inherit"
          variant="fullWidth"
          sx={{
            minHeight: isXsScreen ? "40px" : "48px",
            backgroundColor: "#101010",
            "& .MuiTabs-indicator": {
              backgroundColor: "#64b5f6",
              height: "3px",
            },
            "& .MuiTab-root": {
              color: "rgba(255, 255, 255, 0.7)",
              minWidth: isXsScreen ? "90px" : "120px",
              minHeight: isXsScreen ? "40px" : "48px",
              padding: isXsScreen ? "8px 12px" : "12px 24px",
              textTransform: "none",
              fontWeight: 600,
              "&.Mui-selected": {
                color: "#64b5f6",
              },
              "&:hover": {
                backgroundColor: "rgba(255, 255, 255, 0.05)",
              },
            },
          }}
        >
          <Tab
            label="Box Score"
            sx={{
              fontSize: isXsScreen ? "0.8rem" : isMobile ? "0.875rem" : "1rem",
            }}
          />
          <Tab
            label="Play by Play"
            sx={{
              fontSize: isXsScreen ? "0.8rem" : isMobile ? "0.875rem" : "1rem",
            }}
          />
        </Tabs>
      </Box>

      <DialogContent
        sx={{
          backgroundColor: "#101010",
          padding: 0,
          flex: 1,
          overflow: "hidden",
          position: "relative",
        }}
      >
        <Box
          sx={{
            height: "100%",
            overflow: "auto",
            p: 0,
            "&::-webkit-scrollbar": {
              width: "8px",
            },
            "&::-webkit-scrollbar-track": {
              background: "rgba(255, 255, 255, 0.05)",
            },
            "&::-webkit-scrollbar-thumb": {
              background: "rgba(255, 255, 255, 0.2)",
              borderRadius: "4px",
              "&:hover": {
                background: "rgba(255, 255, 255, 0.3)",
              },
            },
            mx: isMobile ? "auto" : 0, // Center content on mobile
            width: "100%",
            maxWidth: "100%",
          }}
        >
          {activeTab === 0 ? (
            <BoxScore game={gameId} open={open} />
          ) : (
            <PlayByPlay gameId={game_id} />
          )}
        </Box>
      </DialogContent>
    </Dialog>
  );
};

export default GameDetailsModal;

================================================
File: components/NBAPlayerStats.jsx
================================================
// NBAPlayerStats.jsx
import React, { useState } from "react";
import { Box, Container, Typography, useMediaQuery, Alert } from "@mui/material";
import PlayerSearch from "./common/player/PlayerSearch";
import PlayerHeader from "./common/player/PlayerHeader";
import PlayerGameStats from "./common/player/PlayerGameStats";
import Header from "./common/Header";
import { searchPlayersByName, fetchPlayerGameStats } from "../services/playerService";

/**
 * Component for displaying NBA player statistics
 * 
 * @returns {JSX.Element} - Rendered component
 */
const NBAPlayerStats = () => {
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedPlayer, setSelectedPlayer] = useState(null);
  const [searchResults, setSearchResults] = useState([]);
  const [playerStats, setPlayerStats] = useState(null);
  const [showMore, setShowMore] = useState(false);
  const [isSearching, setIsSearching] = useState(false);
  const [searchError, setSearchError] = useState(null);
  const [statsError, setStatsError] = useState(null);
  const [isLoadingStats, setIsLoadingStats] = useState(false);
  
  const isMobile = useMediaQuery("(max-width:600px)");

  /**
   * Handle search query change and fetch matching players
   * 
   * @param {string} query - Search query
   */
  const handleSearchChange = async (query) => {
    setSearchQuery(query);
    setSearchError(null); // Clear previous errors
    
    if (query.length >= 2) {
      setIsSearching(true);
      try {
        const results = await searchPlayersByName(query);
        setSearchResults(results);
      } catch (error) {
        console.error("Error in search:", error);
        setSearchError("Failed to search for players. Please try again.");
        setSearchResults([]);
      } finally {
        setIsSearching(false);
      }
    } else {
      setSearchResults([]);
    }
  };

  /**
   * Handle player selection and fetch their stats
   * 
   * @param {Object} player - Selected player object
   */
  const handlePlayerSelect = async (player) => {
    setSelectedPlayer(player);
    setShowMore(false);
    setStatsError(null); // Clear previous errors
    
    if (player) {
      setIsLoadingStats(true);
      try {
        const stats = await fetchPlayerGameStats(player.person_id, 10);
        if (stats) {
          setPlayerStats(stats);
        } else {
          setStatsError("Could not load player statistics");
        }
      } catch (error) {
        console.error("Error fetching player stats:", error);
        setStatsError(`Failed to fetch statistics for ${player.display_name}`);
      } finally {
        setIsLoadingStats(false);
      }
    }
  };

  /**
   * Handle show more button click to fetch more games
   */
  const handleShowMore = async () => {
    setShowMore(true);
    setStatsError(null);
    
    if (selectedPlayer) {
      setIsLoadingStats(true);
      try {
        const stats = await fetchPlayerGameStats(selectedPlayer.person_id, 25);
        if (stats) {
          setPlayerStats(stats);
        } else {
          setStatsError("Could not load additional game statistics");
        }
      } catch (error) {
        console.error("Error fetching more stats:", error);
        setStatsError("Failed to load additional games");
      } finally {
        setIsLoadingStats(false);
      }
    }
  };

  return (
    <Container
      maxWidth="xl"
      sx={{
        py: isMobile ? 2 : 4,
        px: isMobile ? 1 : 2,
        height: "100%",
        display: "flex",
        flexDirection: "column",
        maxWidth: "1400px !important",
      }}
    >
      {/* Header */}
      <Header
        title="Player Statistics"
      />
      
      {/* Search */}
      <Box sx={{ 
        width: "100%", 
        maxWidth: "600px", 
        mb: 3,
        mx: "auto"
      }}>
        <PlayerSearch
          searchQuery={searchQuery}
          searchResults={searchResults}
          onSearchChange={handleSearchChange}
          onPlayerSelect={handlePlayerSelect}
          isLoading={isSearching}
          error={searchError}
        />
      </Box>

      {statsError && (
        <Alert 
          severity="error" 
          sx={{ 
            mb: 2, 
            width: "100%",
            backgroundColor: "#350000", 
            color: "white"
          }}
        >
          {statsError}
        </Alert>
      )}

      {isLoadingStats && !playerStats && (
        <Box
          sx={{
            textAlign: "center",
            py: isMobile ? 4 : 6,
            opacity: 0.7,
          }}
        >
          <Typography
            variant={isMobile ? "body1" : "h6"}
            sx={{
              fontSize: isMobile ? "0.875rem" : "1rem",
            }}
          >
            Loading player statistics...
          </Typography>
        </Box>
      )}

      {playerStats && (
        <Box
          sx={{
            overflow: "auto",
            flex: 1,
            width: "100%",
          }}
        >
          <PlayerHeader playerInfo={playerStats.player_info} />

          <PlayerGameStats
            games={playerStats.games}
            showMore={showMore}
            onShowMore={handleShowMore}
            isLoading={isLoadingStats && showMore}
          />
        </Box>
      )}

      {/* Empty State */}
      {!playerStats && !isLoadingStats && !statsError && (
        <Box
          sx={{
            textAlign: "center",
            py: isMobile ? 4 : 6,
            opacity: 0.7,
          }}
        >
          <Typography
            variant={isMobile ? "body1" : "h6"}
            sx={{
              fontSize: isMobile ? "0.875rem" : "1rem",
            }}
          >
            Search for a player to view their stats
          </Typography>
        </Box>
      )}
    </Container>
  );
};

export default NBAPlayerStats;

================================================
File: components/PlayByPlay.jsx
================================================
import React, { useState, useEffect, useRef } from "react";
import {
  Box,
  Typography,
  CircularProgress,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  useMediaQuery,
  Alert,
} from "@mui/material";

const PlayByPlay = ({ gameId }) => {
  const [actions, setActions] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [initialLoadComplete, setInitialLoadComplete] = useState(false);
  const socketRef = useRef(null);
  const isMobile = useMediaQuery("(max-width:600px)");
  console.log(actions);

  useEffect(() => {
    setLoading(true);
    setInitialLoadComplete(false);
    setError(null);

    if (!gameId) {
      setError("Missing game ID");
      setLoading(false);
      return;
    }

    const minimumLoadingTimer = setTimeout(() => {
      setInitialLoadComplete(true);
    }, 200);

    // Use environment variable for WebSocket URL with fallback
    const wsBaseUrl = "ws://localhost:8000/api/v1/scoreboard";
    // Use the correct path that works: "ws://localhost:8000/ws/playbyplay/0022400824"
    const socketUrl = `${wsBaseUrl}/ws/playbyplay/${gameId}`;
    console.log("Connecting to:", socketUrl);

    try {
      const socket = new WebSocket(socketUrl);
      socketRef.current = socket;

      socket.onopen = () => {
        console.log("PlayByPlay WebSocket connected");
        setError(null);
      };

      socket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          console.log("PlayByPlay data received:", data);
          
          // Handle different data structures that might come from the backend
          if (data.game?.actions) {
            // Original expected format
            const sorted = [...data.game.actions].sort(
              (a, b) => b.actionNumber - a.actionNumber
            );
            setActions(sorted);
          } else if (data.plays) {
            // NBA API format - "plays" array direct from API
            const formattedActions = data.plays.map(play => ({
              actionNumber: play.eventId || play.actionNumber,
              clock: play.clock,
              period: play.period,
              teamTricode: play.teamTricode,
              scoreAway: play.scoreAway || play.scoreVisitor || (play.scoreDisplay ? play.scoreDisplay.split('-')[0].trim() : ""),
              scoreHome: play.scoreHome || play.scoreHome || (play.scoreDisplay ? play.scoreDisplay.split('-')[1].trim() : ""),
              actionType: play.actionType || play.eventType || "",
              description: play.description
            }));
            
            const sorted = formattedActions.sort((a, b) => b.actionNumber - a.actionNumber);
            setActions(sorted);
          } else if (Array.isArray(data)) {
            // Direct array of plays
            const formattedActions = data.map(play => ({
              actionNumber: play.eventId || play.actionNumber || 0,
              clock: play.clock || "",
              period: play.period || 0,
              teamTricode: play.teamTricode || "",
              scoreAway: play.scoreAway || play.scoreVisitor || "",
              scoreHome: play.scoreHome || play.scoreHome || "",
              actionType: play.actionType || play.eventType || "",
              description: play.description || ""
            }));
            
            const sorted = formattedActions.sort((a, b) => b.actionNumber - a.actionNumber);
            setActions(sorted);
          } else {
            console.warn("Unknown data format received:", data);
          }
          
          setLoading(false);
        } catch (err) {
          console.error("Error parsing PBP data:", err, event.data);
          setError("Error processing game data");
          setLoading(false);
        }
      };

      socket.onerror = (err) => {
        console.error("PlayByPlay socket error:", err);
        setError("Connection error occurred");
        setLoading(false);
      };

      socket.onclose = () => {
        console.log("PlayByPlay socket disconnected");
        if (!error) {
          setError("Connection closed");
        }
      };

      return () => {
        clearTimeout(minimumLoadingTimer);
        if (
          socketRef.current &&
          socketRef.current.readyState === WebSocket.OPEN
        ) {
          socketRef.current.close();
        }
      };
    } catch (err) {
      console.error("Error setting up WebSocket:", err);
      setError("Failed to establish connection");
      setLoading(false);
    }
  }, [gameId]);

  if (loading || !initialLoadComplete) {
    return (
      <Box
        sx={{
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          height: "200px",
        }}
      >
        <CircularProgress sx={{ color: "#64b5f6" }} />
      </Box>
    );
  }

  if (error) {
    return (
      <Box sx={{ p: 2, height: "100%" }}>
        <Alert
          severity="error"
          sx={{
            backgroundColor: "rgba(244, 67, 54, 0.1)",
            color: "#f44336",
            "& .MuiAlert-icon": {
              color: "#f44336",
            },
          }}
        >
          {error}
        </Alert>
      </Box>
    );
  }

  if (actions.length === 0) {
    return (
      <Box
        sx={{
          p: 2,
          height: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
        }}
      >
        <Typography
          sx={{
            color: "rgba(255, 255, 255, 0.7)",
            fontSize: isMobile ? "0.875rem" : "1rem",
          }}
        >
          No play-by-play data available.
        </Typography>
      </Box>
    );
  }

  return (
    <Box
      sx={{
        width: "100%",
        py: 2,
        px: isMobile ? 1 : 3,
        backgroundColor: "#101010",
        overflow: "auto",
        height: "100%",
        display: "flex",
        flexDirection: "column",
        "&::-webkit-scrollbar": {
          display: "none",
        },
        msOverflowStyle: "none",
        scrollbarWidth: "none",
      }}
    >
      <TableContainer
        component={Paper}
        sx={{
          backgroundColor: "#101010",
          borderRadius: "12px",
          border: "1px solid rgba(255, 255, 255, 0.08)",
          boxShadow: "0 4px 20px rgba(0, 0, 0, 0.4)",
          maxHeight: "calc(100vh - 250px)",
          overflow: "auto",
          "&::-webkit-scrollbar": {
            display: "none",
          },
          msOverflowStyle: "none",
          scrollbarWidth: "none",
        }}
      >
        <Table size="small" stickyHeader>
          <TableHead>
            <TableRow>
              <TableCell
                sx={{
                  backgroundColor: "#101010",
                  color: "rgba(255, 255, 255, 0.95)",
                  fontWeight: 600,
                  fontSize: isMobile ? "0.75rem" : "0.875rem",
                  padding: isMobile ? "8px 4px" : "12px 16px",
                  borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
                  width: isMobile ? "60px" : "80px",
                }}
              >
                Clock
              </TableCell>
              <TableCell
                sx={{
                  backgroundColor: "#101010",
                  color: "rgba(255, 255, 255, 0.95)",
                  fontWeight: 600,
                  fontSize: isMobile ? "0.75rem" : "0.875rem",
                  padding: isMobile ? "8px 4px" : "12px 16px",
                  borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
                  width: "60px",
                }}
              >
                Team
              </TableCell>
              <TableCell
                sx={{
                  backgroundColor: "#101010",
                  color: "rgba(255, 255, 255, 0.95)",
                  fontWeight: 600,
                  fontSize: isMobile ? "0.75rem" : "0.875rem",
                  padding: isMobile ? "8px 4px" : "12px 16px",
                  borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
                  width: "100px",
                }}
              >
                Score
              </TableCell>
              <TableCell
                sx={{
                  backgroundColor: "#101010",
                  color: "rgba(255, 255, 255, 0.95)",
                  fontWeight: 600,
                  fontSize: isMobile ? "0.75rem" : "0.875rem",
                  padding: isMobile ? "8px 4px" : "12px 16px",
                  borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
                  width: "100px",
                }}
              >
                Action
              </TableCell>
              <TableCell
                sx={{
                  backgroundColor: "#101010",
                  color: "rgba(255, 255, 255, 0.95)",
                  fontWeight: 600,
                  fontSize: isMobile ? "0.75rem" : "0.875rem",
                  padding: isMobile ? "8px 4px" : "12px 16px",
                  borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
                }}
              >
                Description
              </TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {actions.map((action, index) => (
              <TableRow
                key={action.actionNumber}
                sx={{
                  backgroundColor:
                    index % 2 === 0
                      ? "rgba(255, 255, 255, 0.01)"
                      : "transparent",
                  "&:hover": {
                    backgroundColor: "rgba(255, 255, 255, 0.03)",
                  },
                }}
              >
                <TableCell
                  sx={{
                    color: "rgba(255, 255, 255, 0.87)",
                    padding: isMobile ? "8px 4px" : "12px 16px",
                    fontSize: isMobile ? "0.75rem" : "0.875rem",
                    borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
                  }}
                >
                  {formatClock(action.clock)}
                </TableCell>
                <TableCell
                  sx={{
                    color: "rgba(255, 255, 255, 0.87)",
                    padding: isMobile ? "8px 4px" : "12px 16px",
                    fontSize: isMobile ? "0.75rem" : "0.875rem",
                    borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
                  }}
                >
                  {action.teamTricode || "--"}
                </TableCell>
                <TableCell
                  sx={{
                    color: "#64b5f6",
                    padding: isMobile ? "8px 4px" : "12px 16px",
                    fontSize: isMobile ? "0.75rem" : "0.875rem",
                    borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
                    fontWeight: 500,
                  }}
                >
                  {action.scoreAway} - {action.scoreHome}
                </TableCell>
                <TableCell
                  sx={{
                    color: "rgba(255, 255, 255, 0.87)",
                    padding: isMobile ? "8px 4px" : "12px 16px",
                    fontSize: isMobile ? "0.75rem" : "0.875rem",
                    borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
                  }}
                >
                  {action.actionType}
                </TableCell>
                <TableCell
                  sx={{
                    color: "rgba(255, 255, 255, 0.87)",
                    padding: isMobile ? "8px 4px" : "12px 16px",
                    fontSize: isMobile ? "0.75rem" : "0.875rem",
                    borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
                  }}
                >
                  {action.description}
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    </Box>
  );
};

/**
 * Enhanced clock formatter that handles multiple formats:
 * - ISO 8601 duration format: "PT10M30.5S"
 * - NBA API format: "10:30"
 * - Other text formats like "End of Q1", "Halftime", etc.
 */
const formatClock = (clockStr) => {
  if (!clockStr) return "";

  // If it's already formatted as MM:SS or M:SS
  if (/^\d+:\d+(\.\d+)?$/.test(clockStr)) {
    return clockStr;
  }
  
  // Handle ISO 8601 duration format (PT10M30.5S)
  if (clockStr.startsWith("PT")) {
    // Try full format with minutes and seconds
    let match = clockStr.match(/PT(\d+)M(\d+(\.\d+)?)S/);
    if (match) {
      const minutes = parseInt(match[1]) || 0;
      let seconds = parseFloat(match[2]) || 0;
      seconds = Math.round(seconds * 10) / 10;
      
      return `${minutes}:${seconds.toFixed(1).padStart(4, "0")}`.replace(/\.0$/, "");
    }
    
    // Try minutes-only format (PT10M)
    match = clockStr.match(/PT(\d+)M/);
    if (match) {
      const minutes = parseInt(match[1]) || 0;
      return `${minutes}:00`;
    }
    
    // Try seconds-only format (PT30.5S)
    match = clockStr.match(/PT(\d+(\.\d+)?)S/);
    if (match) {
      const seconds = parseFloat(match[1]) || 0;
      return `0:${seconds.toFixed(1).padStart(4, "0")}`.replace(/\.0$/, "");
    }
  }
  
  // Return original string for other formats
  return clockStr;
};

export default PlayByPlay;

================================================
File: components/Scoreboard.jsx
================================================
// Scoreboard.jsx
import React, { useState } from "react";
import { Box, Container, Typography, useMediaQuery } from "@mui/material";
import GameDetailsModal from "./GameDetailsModal";
import Header from "./common/Header";
import GameCard from "./common/GameCard";
import GameCategorySection from "./common/GameCategorySection";
import { categorizeGames } from "../utils/dateUtils";

/**
 * Main scoreboard component for displaying live games
 * 
 * @param {Object} props - Component props
 * @param {Array} props.games - List of games to display
 * @param {boolean} props.isConnected - Connection status
 * @param {Date} props.lastUpdateTime - Time of last update
 * @returns {JSX.Element} - Rendered component
 */
const Scoreboard = ({ games, isConnected, lastUpdateTime }) => {
  const isMobile = useMediaQuery("(max-width:600px)");
  const [selectedGame, setSelectedGame] = useState(null);
  const [boxScoreOpen, setBoxScoreOpen] = useState(false);
  const [showCompletedGames, setShowCompletedGames] = useState(true);

  // Categorize games into live, scheduled, and completed
  const { liveGames, scheduledGames, completedGames } = categorizeGames(games);

  // Click handler for an in-progress or completed game => open modal
  const handleBoxScoreClick = (game) => {
    setSelectedGame(game);
    setBoxScoreOpen(true);
  };

  return (
    <Container
      maxWidth="xl"
      sx={{
        py: isMobile ? 2 : 4,
        px: isMobile ? 1 : 2,
        height: "100%",
        display: "flex",
        flexDirection: "column",
        maxWidth: "1400px !important",
      }}
    >
      {/* Header */}
      <Header
        title="Scoreboard"
      />

      {/* Game Sections */}
      <GameCategorySection 
        games={liveGames} 
        title="Live Games" 
        onBoxScoreClick={handleBoxScoreClick} 
        isLive={true}
      />
      
      <GameCategorySection 
        games={scheduledGames} 
        title="Upcoming Games" 
        onBoxScoreClick={handleBoxScoreClick}
      />
      
      <GameCategorySection 
        games={completedGames} 
        title="Completed Games" 
        onBoxScoreClick={handleBoxScoreClick}
        collapsible={true}
        expanded={showCompletedGames}
        onToggleExpand={() => setShowCompletedGames(!showCompletedGames)}
      />

      {/* Game Details Modal */}
      <GameDetailsModal
        gameId={selectedGame}
        open={boxScoreOpen}
        onClose={() => {
          setBoxScoreOpen(false);
          setSelectedGame(null);
        }}
      />

      {/* Empty State */}
      {games.length === 0 && (
        <Box
          sx={{
            textAlign: "center",
            py: isMobile ? 4 : 6,
            opacity: 0.7,
          }}
        >
          <Typography
            variant={isMobile ? "body1" : "h6"}
            sx={{
              fontSize: isMobile ? "0.875rem" : "1rem",
            }}
          >
            No games scheduled
          </Typography>
        </Box>
      )}
    </Container>
  );
};

export default Scoreboard;

================================================
File: components/Standings.jsx
================================================
import { useState, useEffect, memo, useMemo, useCallback } from "react";
import {
  Box,
  Container,
  Typography,
  Tab,
  Tabs,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  useMediaQuery,
  CircularProgress,
} from "@mui/material";
import { useTheme } from "@mui/material/styles";
import PropTypes from "prop-types";
import Header from "./common/Header";

// Import the team logo mapping
import { teamLogos } from "../assets/nba_logos/teamLogosMap";

// Create direct mapping for team identifiers to avoid conditional logic
const TEAM_ABBR_MAP = {
  "Atlanta Hawks": "ATL",
  "Boston Celtics": "BOS",
  "Brooklyn Nets": "BKN",
  "Charlotte Hornets": "CHA",
  "Chicago Bulls": "CHI",
  "Cleveland Cavaliers": "CLE",
  "Dallas Mavericks": "DAL",
  "Denver Nuggets": "DEN",
  "Detroit Pistons": "DET",
  "Golden State Warriors": "GSW",
  "Houston Rockets": "HOU",
  "Indiana Pacers": "IND",
  "LA Clippers": "LAC",
  "Los Angeles Lakers": "LAL",
  "Memphis Grizzlies": "MEM",
  "Miami Heat": "MIA",
  "Milwaukee Bucks": "MIL",
  "Minnesota Timberwolves": "MIN",
  "New Orleans Pelicans": "NOP",
  "New York Knicks": "NYK",
  "Oklahoma City Thunder": "OKC",
  "Orlando Magic": "ORL",
  "Philadelphia 76ers": "PHI",
  "Phoenix Suns": "PHX",
  "Portland Trail Blazers": "POR",
  "Sacramento Kings": "SAC",
  "San Antonio Spurs": "SAS",
  "Toronto Raptors": "TOR",
  "Utah Jazz": "UTA",
  "Washington Wizards": "WAS",
};

// Pre-define column headers to avoid recreating object on each render
const COLUMN_HEADERS = {
  team: "Team",
  w: "W",
  l: "L",
  pct: "PCT",
  gb: "GB",
  home: "Home",
  away: "Away",
  div: "Div",
  conf: "Conf",
  last10: "L10",
  strk: "Strk",
};

// Short column headers for extra small screens
const MOBILE_COLUMN_HEADERS = {
  team: "Team",
  w: "W",
  l: "L",
  pct: "%",
  gb: "GB",
  home: "Home",
  away: "Away",
  div: "Div",
  conf: "Conf",
  last10: "L10",
  strk: "Strk",
};

// Memoized TabPanel component
const TabPanel = memo(function TabPanel(props) {
  const { children, value, index, ...other } = props;
  const isMobile = useMediaQuery("(max-width:600px)");

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`standings-tabpanel-${index}`}
      aria-labelledby={`standings-tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ p: isMobile ? 1 : 3 }}>{children}</Box>}
    </div>
  );
});

TabPanel.propTypes = {
  children: PropTypes.node,
  index: PropTypes.number.isRequired,
  value: PropTypes.number.isRequired,
};

// Memoized TeamCell component to reduce rerenders
const TeamCell = memo(function TeamCell({ team, isMobile, isXsScreen }) {
  // Get team identifier for logo lookup
  const teamIdentifier = `${team.team_city} ${team.team_name}`;
  const teamAbbr =
    TEAM_ABBR_MAP[teamIdentifier] ||
    team.team_name.substring(0, 3).toUpperCase();
  const logo = teamLogos[teamAbbr];

  // Display only team name on mobile, abbreviation on extra small screens
  const displayName = isXsScreen
    ? teamAbbr
    : isMobile
    ? team.team_name
    : teamIdentifier;

  return (
    <TableCell
      sx={{
        color: "#ffffff",
        padding: isXsScreen
          ? "8px 2px 8px 4px"
          : isMobile
          ? "10px 6px 10px 2px"
          : "16px 16px 16px 4px", // Reduced left padding
        whiteSpace: "nowrap",
        overflow: "hidden",
        textOverflow: "ellipsis",
        maxWidth: isXsScreen ? "70px" : isMobile ? "100px" : "180px",
        height: isXsScreen ? "40px" : isMobile ? "44px" : "48px", // Set consistent height for all cells
      }}
    >
      <Box
        sx={{
          display: "flex",
          alignItems: "center",
          gap: isXsScreen ? 0.5 : 1,
        }}
      >
        {logo && (
          <Box
            component="img"
            src={logo}
            alt={teamIdentifier}
            sx={{
              width: isXsScreen ? 16 : 24,
              height: isXsScreen ? 16 : 24,
              display: "block", // Show logo on all screen sizes
            }}
            loading="lazy" // Use lazy loading for images
          />
        )}
        <Typography
          sx={{
            fontSize: isXsScreen ? "0.7rem" : isMobile ? "0.8rem" : "0.875rem",
            whiteSpace: "nowrap",
            overflow: "hidden",
            textOverflow: "ellipsis",
          }}
        >
          {displayName}
        </Typography>
      </Box>
    </TableCell>
  );
});

TeamCell.propTypes = {
  team: PropTypes.object.isRequired,
  isMobile: PropTypes.bool.isRequired,
  isXsScreen: PropTypes.bool.isRequired,
};

// Memoized StandingsTable component
const StandingsTable = memo(function StandingsTable({ standings }) {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("sm"));
  const isXsScreen = useMediaQuery("(max-width:430px)");
  const isPortrait = useMediaQuery("(orientation: portrait)");

  // Memoize columns to display based on screen size
  const columnsToDisplay = useMemo(() => {
    if (isXsScreen && isPortrait) {
      return ["team", "w", "l", "pct", "strk"];
    }
    if (isMobile) {
      return ["team", "w", "l", "pct", "gb", "strk"];
    }
    return [
      "team",
      "w",
      "l",
      "pct",
      "gb",
      "home",
      "away",
      "div",
      "conf",
      "last10",
      "strk",
    ];
  }, [isMobile, isXsScreen, isPortrait]);

  // Get appropriate headers based on screen size
  const headers = isXsScreen ? MOBILE_COLUMN_HEADERS : COLUMN_HEADERS;

  // Calculate cell padding based on screen size
  const getCellPadding = () => {
    if (isXsScreen) return "8px 2px";
    if (isMobile) return "10px 4px";
    return "16px";
  };

  return (
    <TableContainer
      component={Paper}
      sx={{
        backgroundColor: "#262626",
        maxHeight: isXsScreen ? "calc(100vh - 180px)" : "calc(100vh - 220px)",
        overflow: "auto",
        "&::-webkit-scrollbar": {
          width: "6px",
          height: "6px",
        },
        "&::-webkit-scrollbar-track": {
          background: "rgba(255, 255, 255, 0.05)",
        },
        "&::-webkit-scrollbar-thumb": {
          background: "rgba(255, 255, 255, 0.2)",
          borderRadius: "3px",
          "&:hover": {
            background: "rgba(255, 255, 255, 0.3)",
          },
        },
      }}
    >
      <Table
        stickyHeader
        aria-label="conference standings table"
        size={isXsScreen ? "small" : isMobile ? "small" : "medium"}
        sx={{ tableLayout: "fixed" }} // Add fixed layout to improve column sizing
      >
        <TableHead>
          <TableRow>
            <TableCell
              sx={{
                backgroundColor: "#1a1a1a",
                color: "#64b5f6",
                fontWeight: "bold",
                padding: getCellPadding(),
                paddingRight: isXsScreen ? "2px" : isMobile ? "4px" : "4px", // Reduced right padding
                paddingLeft: isXsScreen ? "8px" : isMobile ? "12px" : "16px",
                fontSize: isXsScreen
                  ? "0.7rem"
                  : isMobile
                  ? "0.8rem"
                  : "0.875rem",
                width: isXsScreen ? "24px" : isMobile ? "30px" : "40px", // Narrower rank column
              }}
            >
              {isXsScreen ? "#" : "Rank"}
            </TableCell>
            {columnsToDisplay.map((column) => (
              <TableCell
                key={column}
                align={column !== "team" ? "right" : "left"}
                sx={{
                  backgroundColor: "#1a1a1a",
                  color: "#64b5f6",
                  fontWeight: "bold",
                  minWidth:
                    column === "team"
                      ? isXsScreen
                        ? 80
                        : isMobile
                        ? 120
                        : 200
                      : isXsScreen
                      ? "auto"
                      : "40px",
                  width:
                    column === "team"
                      ? isXsScreen
                        ? 80
                        : isMobile
                        ? 120
                        : 200
                      : column === "w" || column === "l"
                      ? isXsScreen
                        ? "24px"
                        : isMobile
                        ? "30px"
                        : "40px"
                      : "auto",
                  padding: getCellPadding(),
                  paddingLeft:
                    column === "team"
                      ? isXsScreen
                        ? "2px"
                        : "4px"
                      : undefined, // Reduced left padding for team column
                  paddingRight:
                    column === "strk"
                      ? isXsScreen
                        ? "8px"
                        : isMobile
                        ? "12px"
                        : "16px"
                      : undefined,
                  fontSize: isXsScreen
                    ? "0.7rem"
                    : isMobile
                    ? "0.8rem"
                    : "0.875rem",
                  whiteSpace: "nowrap",
                }}
              >
                {headers[column]}
              </TableCell>
            ))}
          </TableRow>
        </TableHead>
        <TableBody>
          {standings.map((team) => {
            const isTopSixTeam = team.conference_rank <= 6;
            const isPlayInTeam =
              team.conference_rank > 6 && team.conference_rank <= 10;
            const isWinStreak = !team.streak.startsWith("-");

            return (
              <TableRow
                key={team.team_id}
                sx={{
                  "&:hover": { backgroundColor: "#333333" },
                  backgroundColor: isTopSixTeam
                    ? "rgba(100, 181, 246, 0.1)"
                    : isPlayInTeam
                    ? "rgba(100, 181, 246, 0.05)"
                    : "transparent",
                }}
              >
                <TableCell
                  sx={{
                    color: "#ffffff",
                    padding: getCellPadding(),
                    paddingRight: isXsScreen ? "2px" : isMobile ? "4px" : "4px", // Reduced right padding
                    paddingLeft: isXsScreen
                      ? "8px"
                      : isMobile
                      ? "12px"
                      : "16px",
                    fontSize: isXsScreen
                      ? "0.7rem"
                      : isMobile
                      ? "0.8rem"
                      : "0.875rem",
                    height: isXsScreen ? "40px" : isMobile ? "44px" : "48px", // Set consistent height for all cells
                    width: isXsScreen ? "24px" : isMobile ? "30px" : "40px", // Match header width
                  }}
                >
                  {team.conference_rank}
                </TableCell>

                {columnsToDisplay.includes("team") && (
                  <TeamCell
                    team={team}
                    isMobile={isMobile}
                    isXsScreen={isXsScreen}
                  />
                )}

                {columnsToDisplay.includes("w") && (
                  <TableCell
                    align="right"
                    sx={{
                      color: "#ffffff",
                      padding: getCellPadding(),
                      fontSize: isXsScreen
                        ? "0.7rem"
                        : isMobile
                        ? "0.8rem"
                        : "0.875rem",
                      height: isXsScreen ? "40px" : isMobile ? "44px" : "48px", // Set consistent height for all cells
                      width: isXsScreen ? "24px" : isMobile ? "30px" : "40px", // Match header width
                    }}
                  >
                    {team.wins}
                  </TableCell>
                )}
                {columnsToDisplay.includes("l") && (
                  <TableCell
                    align="right"
                    sx={{
                      color: "#ffffff",
                      padding: getCellPadding(),
                      fontSize: isXsScreen
                        ? "0.7rem"
                        : isMobile
                        ? "0.8rem"
                        : "0.875rem",
                      height: isXsScreen ? "40px" : isMobile ? "44px" : "48px", // Set consistent height for all cells
                      width: isXsScreen ? "24px" : isMobile ? "30px" : "40px", // Match header width
                    }}
                  >
                    {team.losses}
                  </TableCell>
                )}
                {/* Remaining cells remain the same */}

                {/* Rest of the columns stay the same */}
                {columnsToDisplay.includes("pct") && (
                  <TableCell
                    align="right"
                    sx={{
                      color: "#ffffff",
                      padding: getCellPadding(),
                      fontSize: isXsScreen
                        ? "0.7rem"
                        : isMobile
                        ? "0.8rem"
                        : "0.875rem",
                      height: isXsScreen ? "40px" : isMobile ? "44px" : "48px",
                    }}
                  >
                    {isXsScreen
                      ? team.win_pct.toFixed(2)
                      : team.win_pct.toFixed(3)}
                  </TableCell>
                )}
                {columnsToDisplay.includes("gb") && (
                  <TableCell
                    align="right"
                    sx={{
                      color: "#ffffff",
                      padding: getCellPadding(),
                      fontSize: isXsScreen
                        ? "0.7rem"
                        : isMobile
                        ? "0.8rem"
                        : "0.875rem",
                      height: isXsScreen ? "40px" : isMobile ? "44px" : "48px",
                    }}
                  >
                    {team.games_back}
                  </TableCell>
                )}
                {columnsToDisplay.includes("home") && (
                  <TableCell
                    align="right"
                    sx={{
                      color: "#ffffff",
                      padding: getCellPadding(),
                      fontSize: isXsScreen
                        ? "0.7rem"
                        : isMobile
                        ? "0.8rem"
                        : "0.875rem",
                      height: isXsScreen ? "40px" : isMobile ? "44px" : "48px",
                    }}
                  >
                    {team.home_record}
                  </TableCell>
                )}
                {columnsToDisplay.includes("away") && (
                  <TableCell
                    align="right"
                    sx={{
                      color: "#ffffff",
                      padding: getCellPadding(),
                      fontSize: isXsScreen
                        ? "0.7rem"
                        : isMobile
                        ? "0.8rem"
                        : "0.875rem",
                      height: isXsScreen ? "40px" : isMobile ? "44px" : "48px",
                    }}
                  >
                    {team.road_record}
                  </TableCell>
                )}
                {columnsToDisplay.includes("div") && (
                  <TableCell
                    align="right"
                    sx={{
                      color: "#ffffff",
                      padding: getCellPadding(),
                      fontSize: isXsScreen
                        ? "0.7rem"
                        : isMobile
                        ? "0.8rem"
                        : "0.875rem",
                      height: isXsScreen ? "40px" : isMobile ? "44px" : "48px",
                    }}
                  >
                    {team.division_record}
                  </TableCell>
                )}
                {columnsToDisplay.includes("conf") && (
                  <TableCell
                    align="right"
                    sx={{
                      color: "#ffffff",
                      padding: getCellPadding(),
                      fontSize: isXsScreen
                        ? "0.7rem"
                        : isMobile
                        ? "0.8rem"
                        : "0.875rem",
                      height: isXsScreen ? "40px" : isMobile ? "44px" : "48px",
                    }}
                  >
                    {team.conference_record}
                  </TableCell>
                )}
                {columnsToDisplay.includes("last10") && (
                  <TableCell
                    align="right"
                    sx={{
                      color: "#ffffff",
                      padding: getCellPadding(),
                      fontSize: isXsScreen
                        ? "0.7rem"
                        : isMobile
                        ? "0.8rem"
                        : "0.875rem",
                      height: isXsScreen ? "40px" : isMobile ? "44px" : "48px",
                    }}
                  >
                    {team.last_ten}
                  </TableCell>
                )}
                {columnsToDisplay.includes("strk") && (
                  <TableCell
                    align="right"
                    sx={{
                      color: isWinStreak ? "#4caf50" : "#ff6b6b",
                      fontWeight: "bold",
                      padding: getCellPadding(),
                      paddingRight: isXsScreen
                        ? "8px"
                        : isMobile
                        ? "12px"
                        : "16px",
                      fontSize: isXsScreen
                        ? "0.7rem"
                        : isMobile
                        ? "0.8rem"
                        : "0.875rem",
                      height: isXsScreen ? "40px" : isMobile ? "44px" : "48px",
                    }}
                  >
                    {isWinStreak
                      ? `W${team.streak}`
                      : `L${team.streak.substring(1)}`}
                  </TableCell>
                )}
              </TableRow>
            );
          })}
        </TableBody>
      </Table>
    </TableContainer>
  );
});

StandingsTable.propTypes = {
  standings: PropTypes.array.isRequired,
};

// Main Standings component
function Standings() {
  const [tabValue, setTabValue] = useState(0);
  const [standings, setStandings] = useState({ east: [], west: [] });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const isMobile = useMediaQuery("(max-width:600px)");
  const isXsScreen = useMediaQuery("(max-width:430px)");
  const isPortrait = useMediaQuery("(orientation: portrait)");

  const handleTabChange = useCallback((event, newValue) => {
    setTabValue(newValue);
  }, []);

  useEffect(() => {
    const controller = new AbortController();
    const signal = controller.signal;

    const fetchStandings = async () => {
      setLoading(true);
      try {
        // Use a single fetch call with the server that returns all data at once if possible
        // Fallback to parallel fetches with AbortController for cancellation
        const [eastResponse, westResponse] = await Promise.all([
          fetch("http://localhost:8000/api/v1/standings/conference/east", {
            signal,
          }),
          fetch("http://localhost:8000/api/v1/standings/conference/west", {
            signal,
          }),
        ]);

        if (!eastResponse.ok || !westResponse.ok) {
          throw new Error("Failed to fetch standings data");
        }

        const eastData = await eastResponse.json();
        const westData = await westResponse.json();

        // Only sort if necessary (check if first item is already ranked 1)
        const eastSorted =
          eastData[0]?.conference_rank === 1
            ? eastData
            : [...eastData].sort(
                (a, b) => a.conference_rank - b.conference_rank
              );
        const westSorted =
          westData[0]?.conference_rank === 1
            ? westData
            : [...westData].sort(
                (a, b) => a.conference_rank - b.conference_rank
              );

        setStandings({
          east: eastSorted,
          west: westSorted,
        });
        setError(null);
      } catch (err) {
        if (err.name !== "AbortError") {
          setError("Failed to load standings. Please try again later.");
          console.error("Error fetching standings:", err);
        }
      } finally {
        setLoading(false);
      }
    };

    fetchStandings();

    // Cleanup function to abort fetch on unmount
    return () => controller.abort();
  }, []);

  // Only select the current tab's data
  const currentStandings = useMemo(() => {
    return tabValue === 0 ? standings.east : standings.west;
  }, [tabValue, standings]);

  return (
    <Container
      maxWidth="xl"
      sx={{
        py: isXsScreen ? 1 : isMobile ? 2 : 4,
        px: isXsScreen ? 0.5 : isMobile ? 1 : 2,
        height: "100%",
        display: "flex",
        flexDirection: "column",
        maxWidth: "1400px !important",
      }}
    >
      {/* Header */}
      <Header title="NBA Standings" />

      {loading ? (
        <Box sx={{ display: "flex", justifyContent: "center", p: 5 }}>
          <CircularProgress color="primary" />
        </Box>
      ) : error ? (
        <Box sx={{ p: 3, textAlign: "center", color: "#ff6b6b" }}>
          <Typography>{error}</Typography>
        </Box>
      ) : (
        <>
          <Box
            sx={{
              borderBottom: 1,
              borderColor: "divider",
              mb: isXsScreen ? 1 : 2,
            }}
          >
            <Tabs
              value={tabValue}
              onChange={handleTabChange}
              aria-label="conference standings tabs"
              variant={isPortrait ? "fullWidth" : "standard"}
              centered={!isPortrait}
              sx={{
                "& .MuiTab-root": {
                  color: "#888888",
                  fontWeight: "bold",
                  fontSize: isXsScreen
                    ? "0.75rem"
                    : isMobile
                    ? "0.85rem"
                    : "1rem",
                  padding: isXsScreen
                    ? "6px 8px"
                    : isMobile
                    ? "8px 12px"
                    : "12px 16px",
                  minWidth: isXsScreen ? "auto" : undefined,
                  "&.Mui-selected": {
                    color: "#64b5f6",
                  },
                },
                "& .MuiTabs-indicator": {
                  backgroundColor: "#64b5f6",
                },
              }}
            >
              <Tab
                label={
                  isXsScreen
                    ? "East"
                    : isMobile
                    ? "Eastern"
                    : "Eastern Conference"
                }
                id="standings-tab-0"
                aria-controls="standings-tabpanel-0"
              />
              <Tab
                label={
                  isXsScreen
                    ? "West"
                    : isMobile
                    ? "Western"
                    : "Western Conference"
                }
                id="standings-tab-1"
                aria-controls="standings-tabpanel-1"
              />
            </Tabs>
          </Box>

          <TabPanel value={tabValue} index={0}>
            <StandingsTable standings={standings.east} />
          </TabPanel>
          <TabPanel value={tabValue} index={1}>
            <StandingsTable standings={standings.west} />
          </TabPanel>
        </>
      )}
    </Container>
  );
}

export default Standings;


================================================
File: components/common/GameCard.jsx
================================================
import React from "react";
import { Card, CardContent, Box, Typography, Stack, useTheme, useMediaQuery } from "@mui/material";
import TeamInfo from "./TeamInfo";
import { convertToLocalTime, formatGameStartTime } from "../../utils/dateUtils";

/**
 * Single game card component
 * 
 * @param {Object} props - Component props
 * @param {Object} props.game - Game data
 * @param {Function} props.onBoxScoreClick - Click handler for box score
 * @returns {JSX.Element} - Rendered component
 */
const GameCard = ({ game, onBoxScoreClick }) => {
  const theme = useTheme();
  const isMobile = useMediaQuery("(max-width:600px)");
  
  // Extract team info from the game object based on the available structure
  const awayTeam = game.away_team?.team_name || game.away_team;
  const awayTricode = game.away_team?.team_tricode || game.away_tricode;
  const homeTeam = game.home_team?.team_name || game.home_team;
  const homeTricode = game.home_team?.team_tricode || game.home_tricode;
  
  // Handle score based on available structure
  let scoreStr = game.score;
  if (!scoreStr && game.away_team && game.home_team) {
    scoreStr = `${game.away_team.score || 0} - ${game.home_team.score || 0}`;
  }
  
  const [awayScore, homeScore] = (scoreStr || "0 - 0").split(" - ").map(score => parseInt(score) || 0);

  // Determine game status based on properties
  let gameStatus;
  
  // For upcoming games with game_time property
  if (game.game_time && (game.game_status === 1 || game.period === 0)) {
    gameStatus = formatGameStartTime(game.game_time);
    console.log('Game start time formatted:', game.game_id, gameStatus);
  } else if (game.time) {
    // For in-progress and completed games, use the existing time format
    gameStatus = convertToLocalTime(game.time);
  } else if (game.period === 0) {
    gameStatus = "Start: TBD";
  } else if (game.game_status === 2) {
    // Derive time status for in-progress games
    const period = game.period || 1;
    gameStatus = game.clock ? `${period}Q ${game.clock.replace("PT", "").replace("M", ":").replace("S", "").replace(".00", "")}` : `${period}Q`;
  } else if (game.game_status === 3) {
    gameStatus = "Final";
  } else {
    gameStatus = "TBD";
  }

  // Check if game is not started yet
  const isNotStarted = game.game_status === 1 || 
                     game.period === 0 ||
                     gameStatus.startsWith("Start:") || 
                     gameStatus.startsWith("0Q");

  // Hide the score for upcoming games
  const awayDisplayScore = isNotStarted ? "" : awayScore;
  const homeDisplayScore = isNotStarted ? "" : homeScore;

  // Format the game status display (handle "0Q 0:00" as pre-game, etc.)
  const displayStatus = gameStatus === "0Q 0:00" ? "Pre-Game" : gameStatus;

  console.log('Game card rendering:', {
    id: game.game_id,
    awayTeam, 
    awayTricode, 
    homeTeam, 
    homeTricode,
    gameStatus,
    isNotStarted
  });

  return (
    <Card
      onClick={() => {
        if (!isNotStarted) {
          onBoxScoreClick(game);
        }
      }}
      sx={{
        cursor: isNotStarted ? "default" : "pointer",
        mb: isMobile ? 1 : 3,
        backgroundColor: "#262626", // Lighter than background for contrast
        boxShadow: "0 3px 12px rgba(0,0,0,0.3)", // More pronounced shadow
        transition: "all 0.2s ease-in-out",
        "&:hover": {
          transform: isNotStarted ? "none" : "scale(1.01)",
          backgroundColor: "#2d2d2d", // Slightly lighter on hover
        },
        height: isMobile ? "120px" : "150px",
        border: "1px solid rgba(255, 255, 255, 0.08)", // Subtle border
        borderRadius: "12px", // Slightly more rounded corners
        width: "100%",
        maxWidth: "100%",
      }}
    >
      <CardContent
        sx={{
          position: "relative",
          p: isMobile ? "16px !important" : "24px !important",
          height: "100%",
          "&:last-child": {
            paddingBottom: isMobile ? "16px !important" : "24px !important",
          },
        }}
      >
        <Stack
          direction="row"
          justifyContent="space-between"
          alignItems="center"
          sx={{ height: "100%" }}
        >
          <TeamInfo
            teamName={awayTeam}
            tricode={awayTricode}
            score={awayDisplayScore}
            isWinner={!isNotStarted && awayScore > homeScore}
            isHomeTeam={false}
          />

          <Box
            sx={{
              position: "absolute",
              left: "50%",
              top: "50%",
              transform: "translate(-50%, -50%)",
              minWidth: isMobile ? "60px" : "100px",
              textAlign: "center",
            }}
          >
            <Typography
              variant="body2"
              sx={{
                color: "#ffffff",
                opacity: 0.5,
                letterSpacing: "0.5px",
                fontWeight: 400,
                fontSize: isMobile ? "0.875rem" : "1.25rem",
              }}
            >
              {isNotStarted ? displayStatus.replace("Start: ", "") : displayStatus}{" "}
            </Typography>
          </Box>

          <TeamInfo
            teamName={homeTeam}
            tricode={homeTricode}
            score={homeDisplayScore}
            isWinner={!isNotStarted && homeScore > awayScore}
            isHomeTeam={true}
          />
        </Stack>
      </CardContent>
    </Card>
  );
};

export default GameCard;

================================================
File: components/common/GameCategorySection.jsx
================================================
import React from "react";
import { Box, Typography, IconButton, Collapse } from "@mui/material";
import { KeyboardArrowDown, KeyboardArrowUp } from "@mui/icons-material";
import GameCard from "./GameCard";

/**
 * Section for displaying a category of games (live, upcoming, completed)
 * 
 * @param {Object} props - Component props
 * @param {Array} props.games - List of games to display
 * @param {string} props.title - Section title
 * @param {Function} props.onBoxScoreClick - Click handler for box score
 * @param {boolean} props.collapsible - Whether section is collapsible
 * @param {boolean} props.isLive - Whether games are live (displays animated dot)
 * @returns {JSX.Element} - Rendered component
 */
const GameCategorySection = ({ 
  games, 
  title, 
  onBoxScoreClick, 
  collapsible = false,
  expanded = true,
  onToggleExpand,
  isLive = false
}) => {
  const isMobile = window.matchMedia("(max-width:600px)").matches;

  if (games.length === 0) return null;

  return (
    <Box mb={isMobile ? 2 : 4}>
      <Typography
        variant={isMobile ? "subtitle1" : "h6"}
        gutterBottom
        sx={{
          display: "flex",
          justifyContent: collapsible ? "space-between" : "flex-start",
          alignItems: "center",
          fontSize: isMobile ? "1rem" : "1.25rem"
        }}
      >
        <Box sx={{ display: "flex", alignItems: "center" }}>
          {isLive && (
            <Box
              component="span"
              sx={{
                width: isMobile ? 6 : 8,
                height: isMobile ? 6 : 8,
                borderRadius: "50%",
                backgroundColor: "error.main",
                display: "inline-block",
                mr: 1,
                animation: "pulse 2s infinite",
              }}
            />
          )}
          {title}
        </Box>
        
        {collapsible && (
          <IconButton
            size={isMobile ? "small" : "medium"}
            onClick={onToggleExpand}
            sx={{
              ml: 1,
              padding: isMobile ? "4px" : "8px",
            }}
          >
            {expanded ? <KeyboardArrowUp /> : <KeyboardArrowDown />}
          </IconButton>
        )}
      </Typography>

      <Collapse in={expanded}>
        {games.map((game, index) => (
          <GameCard
            key={index}
            game={game}
            onBoxScoreClick={onBoxScoreClick}
          />
        ))}
      </Collapse>
    </Box>
  );
};

export default GameCategorySection;

================================================
File: components/common/Header.jsx
================================================
import React from "react";
import { Box, Typography, useMediaQuery } from "@mui/material";
import NBA from "../../assets/nba_logos/NBA_logo.svg";

/**
 * Header component for scoreboards
 * 
 * @param {Object} props - Component props
 * @param {string} props.title - Title to display
 * @returns {JSX.Element} - Rendered component
 */
const Header = ({ title = "Scoreboard" }) => {
  const isMobile = useMediaQuery("(max-width:600px)");

  return (
    <Box
      sx={{
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        mb: isMobile ? 2 : 3,
        backgroundColor: "#101010",
        borderRadius: 2,
        padding: isMobile ? "12px 16px" : "16px 24px",
        boxShadow: "0 2px 8px rgba(0,0,0,0.2)",
      }}
    >
      <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
        <Box
          component="img"
          src={NBA}
          alt="NBA Logo"
          sx={{
            height: isMobile ? "24px" : "32px",
            width: "auto",
          }}
        />
        <Typography
          variant={isMobile ? "h6" : "h4"}
          sx={{
            fontSize: isMobile ? "1.5rem" : "2rem",
            fontWeight: 500,
            letterSpacing: "0.5px",
            color: "#ffffff",
          }}
        >
          {title}
        </Typography>
      </Box>
    </Box>
  );
};

export default Header;

================================================
File: components/common/TeamInfo.jsx
================================================
import React from "react";
import { Box, Typography, useMediaQuery } from "@mui/material";
import { teamLogos } from "../../assets/nba_logos/teamLogosMap";

/**
 * Renders team information (logo, name, score)
 * 
 * @param {Object} props - Component props
 * @param {string} props.teamName - Full team name
 * @param {string} props.tricode - Team three-letter code
 * @param {string|number} props.score - Team score
 * @param {boolean} props.isWinner - Whether team is the winner
 * @param {boolean} props.isHomeTeam - Whether team is home team
 * @returns {JSX.Element} - Rendered component
 */
const TeamInfo = ({ teamName, tricode, score, isWinner, isHomeTeam }) => {
  const isMobile = useMediaQuery("(max-width:600px)");
  const logoSrc = teamLogos[tricode];

  return (
    <Box
      sx={{
        display: "flex",
        alignItems: "center",
        gap: isMobile ? 1.5 : 3,
        flexDirection: isHomeTeam ? "row-reverse" : "row",
        justifyContent: isHomeTeam ? "flex-start" : "flex-start",
        minWidth: isMobile ? "auto" : "300px",
        flex: isMobile ? 1 : "none",
        width: "100%",
        maxWidth: isHomeTeam ? "45%" : "45%",
      }}
    >
      <Box
        component="img"
        src={logoSrc}
        alt={`${teamName} logo`}
        sx={{
          width: isMobile ? 48 : 72,
          height: isMobile ? 48 : 72,
          objectFit: "contain",
        }}
      />
      <Box
        sx={{
          textAlign: isHomeTeam ? "right" : "left",
          overflow: "hidden",
        }}
      >
        <Typography
          variant="body1"
          fontWeight="600"
          sx={{
            fontSize: isMobile ? "1rem" : "1.5rem",
            whiteSpace: "nowrap",
            color: "rgba(255, 255, 255, 0.95)",
          }}
        >
          {isMobile ? tricode : teamName}
        </Typography>
        {score !== "" && (
          <Typography
            variant={isMobile ? "h5" : "h4"}
            sx={{
              color: isWinner ? "#64b5f6" : "rgba(255, 255, 255, 0.95)",
              fontWeight: isWinner ? 600 : 500,
              fontSize: isMobile ? "1.5rem" : "2rem",
              lineHeight: 1,
              marginTop: "4px",
            }}
          >
            {score}
          </Typography>
        )}
      </Box>
    </Box>
  );
};

export default TeamInfo;

================================================
File: components/common/player/PlayerGameStats.jsx
================================================
import React from "react";
import {
  Box,
  Typography,
  Button,
  useMediaQuery,
  CircularProgress,
} from "@mui/material";
import PlayerStatsTable from "./PlayerStatsTable";

/**
 * Component for displaying player game statistics
 * 
 * @param {Object} props - Component props
 * @param {Array} props.games - List of games with stats
 * @param {boolean} props.showMore - Whether to show more games
 * @param {Function} props.onShowMore - Function to handle show more button click
 * @param {boolean} props.isLoading - Whether data is loading
 * @returns {JSX.Element} - Rendered component
 */
const PlayerGameStats = ({ games, showMore, onShowMore, isLoading = false }) => {
  const isMobile = useMediaQuery("(max-width:600px)");

  if (!games || games.length === 0) return null;

  return (
    <Box>
      <Box
        sx={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          mb: 2,
        }}
      >
        <Typography
          variant="h6"
          sx={{
            color: "white",
            fontWeight: 600,
            fontSize: isMobile ? "1rem" : "1.1rem",
          }}
        >
          Last {showMore ? 25 : 10} Games
        </Typography>
        {!showMore && (
          <Button
            onClick={onShowMore}
            variant="outlined"
            disabled={isLoading}
            startIcon={isLoading ? <CircularProgress size={16} color="inherit" /> : null}
            sx={{
              color: "#64b5f6",
              borderColor: "#64b5f6",
              "&:hover": {
                borderColor: "#90caf9",
                backgroundColor: "rgba(100, 181, 246, 0.08)",
              },
              "&.Mui-disabled": {
                borderColor: "rgba(100, 181, 246, 0.3)",
                color: "rgba(100, 181, 246, 0.3)",
              }
            }}
          >
            {isLoading ? "Loading..." : "Show More"}
          </Button>
        )}
      </Box>

      {isLoading && showMore ? (
        <Box sx={{ display: "flex", justifyContent: "center", py: 4 }}>
          <CircularProgress color="primary" />
        </Box>
      ) : (
        <PlayerStatsTable games={games} />
      )}
    </Box>
  );
};

export default PlayerGameStats;

================================================
File: components/common/player/PlayerHeader.jsx
================================================
import React, { memo } from "react";
import { Box, Avatar, Typography, useMediaQuery } from "@mui/material";
import { getPlayerImageUrl } from "../../../services/playerService";

/**
 * Component for displaying player header information
 * 
 * @param {Object} props - Component props
 * @param {Object} props.playerInfo - Player information object
 * @returns {JSX.Element} - Rendered component
 */
const PlayerHeader = ({ playerInfo }) => {
  const isMobile = useMediaQuery("(max-width:600px)");

  if (!playerInfo) return null;

  return (
    <Box
      sx={{
        display: "flex",
        alignItems: "center",
        mb: 3,
        gap: 2,
      }}
    >
      <Avatar
        src={getPlayerImageUrl(playerInfo.person_id)}
        alt={playerInfo.display_name}
        sx={{
          width: isMobile ? 60 : 80,
          height: isMobile ? 60 : 80,
          border: "2px solid rgba(255, 255, 255, 0.08)",
          backgroundColor: "#262626",
        }}
      />
      <Box>
        <Typography
          variant="h6"
          sx={{
            color: "white",
            fontWeight: 600,
            fontSize: isMobile ? "1.1rem" : "1.25rem",
          }}
        >
          {playerInfo.display_name}
        </Typography>
        <Typography
          sx={{
            color: "#64b5f6",
            fontSize: isMobile ? "1rem" : "1.1rem",
            fontWeight: 500,
          }}
        >
          {playerInfo.team_abbreviation}
        </Typography>
      </Box>
    </Box>
  );
};

export default memo(PlayerHeader);

================================================
File: components/common/player/PlayerSearch.jsx
================================================
import React, { useState, useEffect } from "react";
import { Box, TextField, Autocomplete, Typography, CircularProgress } from "@mui/material";

/**
 * Component for searching NBA players
 * 
 * @param {Object} props - Component props
 * @param {string} props.searchQuery - Current search query
 * @param {Array} props.searchResults - Search results
 * @param {Function} props.onSearchChange - Function to handle search query changes
 * @param {Function} props.onPlayerSelect - Function to handle player selection
 * @param {boolean} props.isLoading - Whether search is in progress
 * @param {string} props.error - Error message if search failed
 * @returns {JSX.Element} - Rendered component
 */
const PlayerSearch = ({ 
  searchQuery, 
  searchResults, 
  onSearchChange, 
  onPlayerSelect,
  isLoading = false,
  error = null 
}) => {
  const [inputValue, setInputValue] = useState('');
  const [noOptionsText, setNoOptionsText] = useState('Start typing to search for players');

  // Update no options text based on query length and loading state
  useEffect(() => {
    if (isLoading) {
      setNoOptionsText('Loading...');
    } else if (error) {
      setNoOptionsText(`Error: ${error}`);
    } else if (inputValue.length > 0 && inputValue.length < 2) {
      setNoOptionsText('Type at least 2 characters to search');
    } else if (inputValue.length >= 2 && searchResults.length === 0) {
      setNoOptionsText('No players found');
    } else {
      setNoOptionsText('Start typing to search for players');
    }
  }, [inputValue, isLoading, error, searchResults]);

  return (
    <Box
      sx={{
        mb: 4,
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        gap: 2,
        width: "100%"
      }}
    >
      <Autocomplete
        options={searchResults}
        getOptionLabel={(option) =>
          `${option.display_name} - ${option.team_abbreviation}`
        }
        onInputChange={(event, newInputValue) => {
          setInputValue(newInputValue);
          onSearchChange(newInputValue);
        }}
        onChange={(event, newValue) => {
          onPlayerSelect(newValue);
        }}
        loading={isLoading}
        noOptionsText={noOptionsText}
        sx={{
          width: "100%",
          maxWidth: 800,
          "& .MuiOutlinedInput-root": {
            backgroundColor: "#262626",
            "&:hover": {
              backgroundColor: "#2d2d2d",
            },
            "& fieldset": {
              borderColor: error ? "red" : "rgba(255, 255, 255, 0.08)",
            },
            "&:hover fieldset": {
              borderColor: error ? "red" : "rgba(255, 255, 255, 0.2)",
            },
            "&.Mui-focused fieldset": {
              borderColor: error ? "red" : theme => theme.palette.primary.main,
            },
          },
        }}
        renderInput={(params) => (
          <TextField
            {...params}
            label="Search for a player"
            variant="outlined"
            InputProps={{
              ...params.InputProps,
              endAdornment: (
                <>
                  {isLoading ? <CircularProgress color="inherit" size={20} /> : null}
                  {params.InputProps.endAdornment}
                </>
              ),
            }}
            sx={{
              "& .MuiInputLabel-root": {
                color: error ? "red" : "rgba(255, 255, 255, 0.7)",
                "&.Mui-focused": {
                  color: error ? "red" : theme => theme.palette.primary.main,
                },
              },
              "& .MuiInputBase-input": {
                color: "white",
              },
            }}
          />
        )}
      />
      
      {error && (
        <Typography 
          color="error" 
          variant="body2" 
          sx={{ width: "100%", maxWidth: 800, textAlign: "left" }}
        >
          Error: {error}
        </Typography>
      )}
    </Box>
  );
};

export default PlayerSearch;

================================================
File: components/common/player/PlayerStatsTable.jsx
================================================
import React, { memo } from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  useMediaQuery,
} from "@mui/material";
import { formatDate } from "../../../utils/dateUtils";

// Table headers with mobile-friendly labels
const TABLE_HEADERS = [
  { full: "Date", short: "Date" },
  { full: "Matchup", short: "Match" },
  { full: "W/L", short: "W/L" },
  { full: "MIN", short: "MIN" },
  { full: "PTS", short: "PTS" },
  { full: "FGM-FGA", short: "FG" },
  { full: "FG%", short: "FG%" },
  { full: "3PM-3PA", short: "3P" },
  { full: "3P%", short: "3P%" },
  { full: "FTM-FTA", short: "FT" },
  { full: "FT%", short: "FT%" },
  { full: "REB", short: "REB" },
  { full: "AST", short: "AST" },
  { full: "STL", short: "STL" },
  { full: "BLK", short: "BLK" },
  { full: "TOV", short: "TOV" },
  { full: "+/-", short: "+/-" },
];

// Column widths for different screen sizes
const getColumnWidths = (isMobile, isXsScreen, isPortrait) => {
  if (isXsScreen && isPortrait) {
    return [
      { width: "8%" }, // Date
      { width: "10%" }, // Matchup
      { width: "4%" }, // W/L
      { width: "5%" }, // MIN
      { width: "5%" }, // PTS
      { width: "7%" }, // FGM-FGA
      { width: "5%" }, // FG%
      { width: "7%" }, // 3PM-3PA
      { width: "5%" }, // 3P%
      { width: "7%" }, // FTM-FTA
      { width: "5%" }, // FT%
      { width: "5%" }, // REB
      { width: "5%" }, // AST
      { width: "5%" }, // STL
      { width: "5%" }, // BLK
      { width: "5%" }, // TOV
      { width: "7%" }, // +/-
    ];
  }
  
  if (isMobile && isPortrait) {
    return [
      { width: "8%" }, // Date
      { width: "11%" }, // Matchup
      { width: "4%" }, // W/L
      { width: "5%" }, // MIN
      { width: "5%" }, // PTS
      { width: "7%" }, // FGM-FGA
      { width: "5%" }, // FG%
      { width: "7%" }, // 3PM-3PA
      { width: "5%" }, // 3P%
      { width: "7%" }, // FTM-FTA
      { width: "5%" }, // FT%
      { width: "5%" }, // REB
      { width: "5%" }, // AST
      { width: "5%" }, // STL
      { width: "5%" }, // BLK
      { width: "5%" }, // TOV
      { width: "6%" }, // +/-
    ];
  }
  
  return [
    { width: "8%" }, // Date
    { width: "12%" }, // Matchup
    { width: "4%" }, // W/L
    { width: "5%" }, // MIN
    { width: "5%" }, // PTS
    { width: "7%" }, // FGM-FGA
    { width: "5%" }, // FG%
    { width: "7%" }, // 3PM-3PA
    { width: "5%" }, // 3P%
    { width: "7%" }, // FTM-FTA
    { width: "5%" }, // FT%
    { width: "5%" }, // REB
    { width: "5%" }, // AST
    { width: "5%" }, // STL
    { width: "5%" }, // BLK
    { width: "5%" }, // TOV
    { width: "5%" }, // +/-
  ];
};

// Format FG, 3P, and FT stats for mobile
const formatStat = (made, attempted, isMobile, isXsScreen) => {
  if (isXsScreen) {
    return `${made}/${attempted}`;
  }
  return `${made}-${attempted}`;
};

// Memoized table cell component with right alignment for numeric cells
const StyledTableCell = memo(({ children, sx = {}, isNumeric = false, ...props }) => (
  <TableCell
    align={isNumeric ? "right" : "left"}
    sx={{
      padding: { xs: "6px 2px", sm: "12px 16px" },
      fontSize: { xs: "0.65rem", sm: "0.875rem" },
      borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
      ...sx,
    }}
    {...props}
  >
    {children}
  </TableCell>
));

// Memoized game row component
const GameRow = memo(({ game, index, isMobile, isXsScreen }) => {
  const isPtsHighlighted = game.pts >= 20;
  const isRebHighlighted = game.reb >= 10;
  const isAstHighlighted = game.ast >= 10;
  const isPlusMinusHighlighted = Math.abs(game.plus_minus) >= 15;

  const formattedFgPct = (game.fg_pct * 100).toFixed(1);
  const formattedFg3Pct = (game.fg3_pct * 100).toFixed(1);
  const formattedFtPct = (game.ft_pct * 100).toFixed(1);
  const formattedDate = formatDate(game.game_date);
  const plusMinusDisplay = game.plus_minus > 0 ? `+${game.plus_minus}` : game.plus_minus;

  // Format matchup for different screen sizes
  const formatMatchup = (matchup) => {
    if (isXsScreen) {
      // Extract team abbreviations only (e.g., "MIL vs. BOS" -> "MIL v BOS")
      const parts = matchup.split(' ');
      if (parts.length >= 3) {
        return `${parts[0]} v ${parts[2].replace(/\.$/, '')}`;
      }
    }
    return matchup;
  };

  return (
    <TableRow
      sx={{
        backgroundColor: index % 2 === 0 ? "rgba(255, 255, 255, 0.01)" : "transparent",
        "&:hover": {
          backgroundColor: "rgba(255, 255, 255, 0.03)",
        },
      }}
    >
      {/* Date */}
      <StyledTableCell sx={{ color: "rgba(255, 255, 255, 0.87)" }}>
        {formattedDate}
      </StyledTableCell>
      
      {/* Matchup */}
      <StyledTableCell sx={{ color: "rgba(255, 255, 255, 0.87)" }}>
        {formatMatchup(game.matchup)}
      </StyledTableCell>
      
      {/* W/L */}
      <StyledTableCell
        sx={{
          color: game.wl === "W" ? "#4caf50" : "#f44336",
          fontWeight: 600,
        }}
      >
        {game.wl}
      </StyledTableCell>
      
      {/* MIN */}
      <StyledTableCell isNumeric sx={{ color: "rgba(255, 255, 255, 0.87)" }}>
        {Math.round(game.min)}
      </StyledTableCell>
      
      {/* PTS */}
      <StyledTableCell
        isNumeric
        sx={{
          color: isPtsHighlighted ? "#64b5f6" : "rgba(255, 255, 255, 0.87)",
          fontWeight: isPtsHighlighted ? 600 : 400,
        }}
      >
        {game.pts}
      </StyledTableCell>
      
      {/* FGM-FGA */}
      <StyledTableCell isNumeric sx={{ color: "rgba(255, 255, 255, 0.87)" }}>
        {formatStat(game.fgm, game.fga, isMobile, isXsScreen)}
      </StyledTableCell>
      
      {/* FG% */}
      <StyledTableCell isNumeric sx={{ color: "rgba(255, 255, 255, 0.87)" }}>
        {isXsScreen ? formattedFgPct : `${formattedFgPct}%`}
      </StyledTableCell>
      
      {/* 3PM-3PA */}
      <StyledTableCell isNumeric sx={{ color: "rgba(255, 255, 255, 0.87)" }}>
        {formatStat(game.fg3m, game.fg3a, isMobile, isXsScreen)}
      </StyledTableCell>
      
      {/* 3P% */}
      <StyledTableCell isNumeric sx={{ color: "rgba(255, 255, 255, 0.87)" }}>
        {isXsScreen ? formattedFg3Pct : `${formattedFg3Pct}%`}
      </StyledTableCell>
      
      {/* FTM-FTA */}
      <StyledTableCell isNumeric sx={{ color: "rgba(255, 255, 255, 0.87)" }}>
        {formatStat(game.ftm, game.fta, isMobile, isXsScreen)}
      </StyledTableCell>
      
      {/* FT% */}
      <StyledTableCell isNumeric sx={{ color: "rgba(255, 255, 255, 0.87)" }}>
        {isXsScreen ? formattedFtPct : `${formattedFtPct}%`}
      </StyledTableCell>
      
      {/* REB */}
      <StyledTableCell
        isNumeric
        sx={{
          color: isRebHighlighted ? "#64b5f6" : "rgba(255, 255, 255, 0.87)",
          fontWeight: isRebHighlighted ? 600 : 400,
        }}
      >
        {game.reb}
      </StyledTableCell>
      
      {/* AST */}
      <StyledTableCell
        isNumeric
        sx={{
          color: isAstHighlighted ? "#64b5f6" : "rgba(255, 255, 255, 0.87)",
          fontWeight: isAstHighlighted ? 600 : 400,
        }}
      >
        {game.ast}
      </StyledTableCell>
      
      {/* STL */}
      <StyledTableCell isNumeric sx={{ color: "rgba(255, 255, 255, 0.87)" }}>
        {game.stl}
      </StyledTableCell>
      
      {/* BLK */}
      <StyledTableCell isNumeric sx={{ color: "rgba(255, 255, 255, 0.87)" }}>
        {game.blk}
      </StyledTableCell>
      
      {/* TOV */}
      <StyledTableCell isNumeric sx={{ color: "rgba(255, 255, 255, 0.87)" }}>
        {game.tov}
      </StyledTableCell>
      
      {/* +/- */}
      <StyledTableCell
        isNumeric
        sx={{
          color: game.plus_minus > 0 ? "#4caf50" : "#f44336",
          fontWeight: isPlusMinusHighlighted ? 600 : 400,
        }}
      >
        {plusMinusDisplay}
      </StyledTableCell>
    </TableRow>
  );
});

// Memoized table header
const TableHeader = memo(({ isMobile, isXsScreen }) => (
  <TableHead>
    <TableRow>
      {TABLE_HEADERS.map((header, index) => {
        const isNumeric = index >= 3; // MIN and all stats after are numeric and right-aligned
        return (
          <TableCell
            key={index}
            align={isNumeric ? "right" : "left"}
            sx={{
              backgroundColor: "#101010",
              color: "rgba(255, 255, 255, 0.95)",
              fontWeight: 600,
              fontSize: isXsScreen ? "0.65rem" : isMobile ? "0.7rem" : "0.875rem",
              padding: isXsScreen ? "6px 2px" : isMobile ? "8px 3px" : "12px 16px",
              borderBottom: "1px solid rgba(255, 255, 255, 0.08)",
              whiteSpace: "nowrap",
              position: "sticky",
              top: 0,
              zIndex: 1,
            }}
          >
            {isXsScreen ? header.short : header.full}
          </TableCell>
        );
      })}
    </TableRow>
  </TableHead>
));

/**
 * Component for displaying player game statistics in a table
 * 
 * @param {Object} props - Component props
 * @param {Array} props.games - List of games with stats
 * @returns {JSX.Element} - Rendered component
 */
const PlayerStatsTable = ({ games }) => {
  const isMobile = useMediaQuery("(max-width:600px)");
  const isXsScreen = useMediaQuery("(max-width:430px)");
  const isPortrait = useMediaQuery("(orientation: portrait)");

  if (!games || games.length === 0) return null;

  const columnWidths = getColumnWidths(isMobile, isXsScreen, isPortrait);
  
  // Adjust table min-width for different screen sizes and orientations
  const getTableMinWidth = () => {
    if (isPortrait) {
      return isXsScreen ? "800px" : isMobile ? "900px" : "1100px";
    }
    return isXsScreen ? "850px" : isMobile ? "950px" : "1200px";
  };

  const tableMinWidth = getTableMinWidth();

  return (
    <TableContainer
      component={Paper}
      sx={{
        backgroundColor: "#101010",
        borderRadius: "12px",
        border: "1px solid rgba(255, 255, 255, 0.08)",
        boxShadow: "0 4px 20px rgba(0, 0, 0, 0.4)",
        overflow: "auto",
        "&::-webkit-scrollbar": {
          height: "6px",
          backgroundColor: "#101010",
        },
        "&::-webkit-scrollbar-thumb": {
          backgroundColor: "rgba(255, 255, 255, 0.2)",
          borderRadius: "3px",
        },
        scrollbarWidth: "thin",
        scrollbarColor: "rgba(255, 255, 255, 0.2) #101010",
        width: "100%",
        maxWidth: "100%",
      }}
    >
      <Table
        size={isXsScreen ? "small" : isMobile ? "small" : "medium"}
        stickyHeader
        sx={{
          minWidth: tableMinWidth,
          width: "100%",
          tableLayout: "fixed",
        }}
      >
        <colgroup>
          {columnWidths.map((col, index) => (
            <col key={index} style={{ width: col.width }} />
          ))}
        </colgroup>
        
        <TableHeader isMobile={isMobile} isXsScreen={isXsScreen} />
        
        <TableBody>
          {games.map((game, index) => (
            <GameRow
              key={`${game.game_date}-${index}`}
              game={game}
              index={index}
              isMobile={isMobile}
              isXsScreen={isXsScreen}
            />
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );
};

export default memo(PlayerStatsTable);

================================================
File: hooks/useWebSocket.js
================================================
import { useState, useEffect, useRef } from "react";

/**
 * Custom hook for WebSocket connection with automatic reconnection
 * @returns {Object} - Object with games data, connection status, and last update time
 */
const useWebSocket = () => {
  const [games, setGames] = useState([]);
  const [isConnected, setIsConnected] = useState(false);
  const [lastUpdateTime, setLastUpdateTime] = useState(null);

  // Use refs to maintain values across renders
  const wsRef = useRef(null);
  const reconnectTimeoutRef = useRef(null);
  const reconnectAttemptsRef = useRef(0);

  useEffect(() => {
    const ws_url = "ws://localhost:8000/api/v1/scoreboard/ws";
    console.log("WebSocket URL:", ws_url);

    /**
     * Connect to WebSocket with exponential backoff for retries
     */
    const connectWebSocket = () => {
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }

      try {
        wsRef.current = new WebSocket(ws_url);

        wsRef.current.onopen = () => {
          console.log("Connected to NBA Stats WebSocket");
          setIsConnected(true);
          reconnectAttemptsRef.current = 0;
        };

        wsRef.current.onmessage = (event) => {
          try {
            // Parse the incoming data
            const rawGamesData = JSON.parse(event.data);

            // Transform the data to match the expected format in the UI
            const transformedGames = rawGamesData.map((game) => {
              // Extract data from nested structure
              return {
                gameId: game.game_id,
                away_team: game.away_team.team_name,
                away_tricode: game.away_team.team_tricode,
                home_team: game.home_team.team_name,
                home_tricode: game.home_team.team_tricode,
                score: `${game.away_team.score} - ${game.home_team.score}`,
                time: formatGameClock(
                  game.clock,
                  game.period,
                  game.game_status
                ),
              };
            });

            setGames(transformedGames);
            setLastUpdateTime(new Date());
          } catch (error) {
            console.error("Error parsing WebSocket message:", error);
          }
        };

        wsRef.current.onerror = (error) => {
          console.log(
            `WebSocket error (attempt ${reconnectAttemptsRef.current + 1}):`,
            error
          );
          setIsConnected(false);
        };

        wsRef.current.onclose = (event) => {
          console.log(
            `WebSocket closed (attempt ${reconnectAttemptsRef.current + 1}):`,
            event.code,
            event.reason
          );
          setIsConnected(false);

          reconnectAttemptsRef.current++;

          // Exponential backoff with max of 10 seconds
          const backoffTime = Math.min(
            1000 * Math.pow(2, reconnectAttemptsRef.current),
            10000
          );
          console.log(`Reconnecting in ${backoffTime}ms...`);

          reconnectTimeoutRef.current = setTimeout(() => {
            console.log("Attempting to reconnect...");
            connectWebSocket();
          }, backoffTime);
        };
      } catch (error) {
        console.error("Error creating WebSocket:", error);
        reconnectTimeoutRef.current = setTimeout(connectWebSocket, 5000);
      }
    };

    // Initial connection attempt with slight delay
    reconnectTimeoutRef.current = setTimeout(() => {
      console.log("Making initial connection attempt...");
      connectWebSocket();
    }, 5);

    // Cleanup function
    return () => {
      if (wsRef.current) {
        wsRef.current.close();
      }
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }
    };
  }, []);

  /**
   * Format the game clock based on period and format received
   */
  const formatGameClock = (clock, period, status) => {
    // Game hasn't started yet
    if (status === 1) {
      return "Start: TBD";
    }

    // Game is completed
    if (status === 3) {
      return "Final";
    }

    // Halftime check - if period is 2 and clock is empty or "0:00"
    if (
      period === 2 &&
      (!clock || clock === "0:00" || clock === "PT00M00.00S")
    ) {
      return "Halftime";
    }

    // Game in progress
    if (clock) {
      // Handle ISO duration format like "PT09M22.00S"
      if (clock.startsWith("PT")) {
        const minutesMatch = clock.match(/PT(\d+)M/);
        const secondsMatch = clock.match(/M(\d+\.\d+)S/);

        const minutes = minutesMatch ? minutesMatch[1] : "0";
        const seconds = secondsMatch
          ? Math.floor(parseFloat(secondsMatch[1]))
          : "00";

        // Format as "1Q 9:22" or similar
        return `${period}Q ${minutes}:${seconds.toString().padStart(2, "0")}`;
      }

      // Already formatted
      return clock;
    }

    return "0Q 0:00";
  };

  return {
    games,
    isConnected,
    lastUpdateTime,
  };
};

export default useWebSocket;


================================================
File: services/apiService.js
================================================
/**
 * API service for handling all HTTP requests to the backend
 */

/**
 * Fetch box score data for a specific game
 * @param {string} gameId - Game ID or object with gameId property
 * @returns {Promise<Object>} - Box score data
 */
export const fetchBoxScore = async (gameId) => {
  if (!gameId) return null;
  
  // If gameId is an object, extract the game_id or gameId
  const id = typeof gameId === 'object' ? (gameId.game_id || gameId.gameId) : gameId;
  
  try {
    const baseUrl = "http://localhost:8000/api/v1/scoreboard/boxscore";
    const response = await fetch(`${baseUrl}/${id}`);
    
    if (!response.ok) {
      console.error(`Box score request failed with status: ${response.status}`);
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching box score data:', error);
    return null;
  }
};

/**
 * Fetch historical games for a specific date
 * @param {Object} date - Date object (dayjs)
 * @returns {Promise<Array>} - Games data
 */
export const fetchHistoricalGames = async (date) => {
  try {
    // Log environment variables for debugging
    console.log("Environment variables:", {
      VITE_SCORE_URL: import.meta.env.VITE_SCORE_URL,
      VITE_BACKEND_URL: import.meta.env.VITE_BACKEND_URL
    });
    
    // Use explicit localhost URL for testing
    const baseUrl = "http://localhost:8000/api/v1/scoreboard/past";
    
    // Format the date as YYYY-MM-DD for the API
    const formattedDate = date.format("YYYY-MM-DD");
    
    // Fixed URL construction with explicit localhost path
    const apiUrl = `${baseUrl}?date=${formattedDate}`;
    
    console.log("Fetching historical games from:", apiUrl);
    const response = await fetch(apiUrl);
    
    if (!response.ok) {
      console.error(`Historical games request failed with status: ${response.status}`);
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    console.log(`Fetched ${data.length} historical games for ${formattedDate}`);
    return data;
  } catch (error) {
    console.error('Error fetching historical games:', error);
    return [];
  }
};

/**
 * Fetch player statistics by name
 * @param {string} playerName - Name of the player
 * @returns {Promise<Object>} - Player statistics data
 */
export const fetchPlayerStats = async (playerName) => {
  try {
    const baseUrl = import.meta.env.VITE_PLAYER_STATS_URL || "http://localhost:8000/api/v1/players/search";
    const response = await fetch(`${baseUrl}/${encodeURIComponent(playerName)}`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error fetching player stats:', error);
    return null;
  }
};

================================================
File: services/playerService.js
================================================
/**
 * Service for player-related API interactions
 */

/**
 * Search players by name query
 * 
 * @param {string} query - Search query 
 * @returns {Promise<Array>} - Array of matching player objects
 */
export const searchPlayersByName = async (query) => {
  if (query.length < 2) return [];
  
  try {
    // Use the exact URL format expected by the backend - without the /api/v1/ prefix
    const baseUrl = import.meta.env.VITE_PLAYER_SEARCH_URL || "http://localhost:8000/api/v1/players/search/";
    
    // Ensure we have the correct URL format with trailing slash before the query parameter
    // The backend expects /players/search/?query=value
    const url = `${baseUrl.endsWith('/') ? baseUrl : baseUrl + '/'}?query=${encodeURIComponent(query)}`;
    
    console.log("Searching players at URL:", url);
    const response = await fetch(url);
    
    if (!response.ok) {
      console.error(`Search request failed with status: ${response.status}`);
      const errorText = await response.text();
      console.error("Error response:", errorText);
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    console.log(`Found ${data.length} players matching "${query}"`);
    return data;
  } catch (error) {
    console.error("Error searching players:", error);
    return [];
  }
};

/**
 * Fetch player game statistics
 * 
 * @param {string} playerId - Player ID
 * @param {number} lastNGames - Number of games to fetch
 * @returns {Promise<Object>} - Player game statistics
 */
export const fetchPlayerGameStats = async (playerId, lastNGames = 10) => {
  if (!playerId) return null;
  
  try {
    const baseUrl = import.meta.env.VITE_PLAYER_GAMES_URL || "http://localhost:8000/api/v1/players";
    // Ensure proper path format with no double slashes
    const url = `${baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl}/${playerId}/games?last_n_games=${lastNGames}`;
    
    console.log("Fetching player stats at URL:", url);
    const response = await fetch(url);
    
    if (!response.ok) {
      console.error(`Stats request failed with status: ${response.status}`);
      const errorText = await response.text();
      console.error("Error response:", errorText);
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    console.log(`Retrieved stats for player ${playerId} (${data?.player_info?.display_name || 'unknown'})`);
    return data;
  } catch (error) {
    console.error("Error fetching player stats:", error);
    return null;
  }
};

/**
 * Get player image URL
 * 
 * @param {string} playerId - Player ID
 * @returns {string|null} - Image URL or null if no ID provided
 */
export const getPlayerImageUrl = (playerId) => {
  if (!playerId) return null;
  const baseUrl = import.meta.env.VITE_PLAYER_IMAGE_URL || "https://cdn.nba.com/headshots/nba/latest/1040x760";
  return `${baseUrl}/${playerId}.png`;
};

================================================
File: styles/AG.css
================================================
@import 'ag-grid-community/styles/ag-grid.css';
/* @import 'ag-grid-community/styles/ag-theme-alpine-dark.css'; */

================================================
File: styles/tailwind.css
================================================
/* src/tailwind.css */
@import "tailwindcss";


================================================
File: styles/theme.js
================================================
import { createTheme } from "@mui/material/styles";

const darkTheme = createTheme({
  typography: {
    // Increase the font size scaling factor
    htmlFontSize: 16 * 1.5, // Base font size scaled by 150%
    fontFamily: [
      '-apple-system',
      'BlinkMacSystemFont',
      '"Segoe UI"',
      'Roboto',
      '"Helvetica Neue"',
      'Arial',
      'sans-serif',
    ].join(','),
    h6: {
      fontSize: '1.25rem',
      fontWeight: 500,
    },
    subtitle1: {
      fontSize: '1rem',
      fontWeight: 400,
    },
    body1: {
      fontSize: '1rem',
      fontWeight: 400,
    },
    body2: {
      fontSize: '0.875rem',
      fontWeight: 400,
    },
    caption: {
      fontSize: '0.75rem',
      fontWeight: 400,
    },
  },
  components: {
    MuiCssBaseline: {
      styleOverrides: {
        body: {
          '[data-theme="dark"]': {
            "--background": "215 25% 7%",
            "--foreground": "210 40% 98%",
            "--card": "215 25% 12%",
            "--card-foreground": "210 40% 98%",
            "--popover": "215 25% 12%",
            "--popover-foreground": "210 40% 98%",
            "--primary": "210 100% 52%",
            "--primary-foreground": "0 0% 100%",
            "--secondary": "215 25% 12%",
            "--secondary-foreground": "210 40% 98%",
            "--muted": "215 25% 12%",
            "--muted-foreground": "217.9 10.6% 75%",
            "--accent": "215 25% 12%",
            "--accent-foreground": "210 40% 98%",
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          backgroundColor: "#101010",
          borderColor: "rgba(255, 255, 255, 0.1)",
          '&:hover': {
            backgroundColor: "#252525",
          },
        },
      },
    },
    // Adjust icon sizes
    MuiSvgIcon: {
      styleOverrides: {
        root: {
          fontSize: '1.5rem', // Increase default icon size
        },
        fontSizeLarge: {
          fontSize: '2.25rem',
        },
        fontSizeSmall: {
          fontSize: '1.125rem',
        },
      },
    },
    // Adjust spacing for cards
    MuiCardContent: {
      styleOverrides: {
        root: {
          padding: '24px', // Increase padding
          '&:last-child': {
            paddingBottom: '24px',
          },
        },
      },
    },
    // Adjust tab sizes
    MuiTab: {
      styleOverrides: {
        root: {
          minHeight: '72px', // Increase tab height
          fontSize: '1rem',
          padding: '12px 24px',
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          backgroundImage: "none",
        },
      },
    },
    MuiDialog: {
      styleOverrides: {
        paper: {
          backgroundColor: "#101010",
        },
      },
    },
    MuiTabs: {
      styleOverrides: {
        root: {
          backgroundColor: "#101010",
          minHeight: '72px', // Match tab height
        },
        indicator: {
          backgroundColor: "#64b5f6",
          height: '3px', // Slightly thicker indicator
        },
      },
    },
  },
  palette: {
    mode: "dark",
    primary: {
      main: "#64b5f6",
      dark: "#1e88e5",
      light: "#90caf9",
    },
    secondary: {
      main: "#ce93d8",
    },
    background: {
      default: "#121212",
      paper: "#101010",
    },
    text: {
      primary: "#ffffff",
      secondary: "rgba(255, 255, 255, 0.85)",
    },
  },
  // Adjust spacing scale
  spacing: factor => `${0.25 * factor * 1.5}rem`, // Scale up spacing by 150%
});

export default darkTheme;

================================================
File: theme/theme.js
================================================
import { createTheme } from '@mui/material/styles';

export const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0',
      contrastText: '#ffffff',
    },
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          textTransform: 'none',
          padding: '8px 24px',
          '&:hover': {
            boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)',
          },
        },
      },
    },
  },
});

================================================
File: utils/dateUtils.js
================================================
/**
 * Converts Eastern Standard Time (EST) to local time
 * @param {string} timeStr - Time string in format "Start: HH:MM PM"
 * @returns {string} - Formatted time string in local timezone
 */
export const convertToLocalTime = (timeStr) => {
  // If it's not a start time (e.g., "1Q 10:44" or "Final"), return as-is.
  if (!timeStr.startsWith("Start:")) {
    return timeStr;
  }

  // Extract the time part
  const [_, timeComponent] = timeStr.split("Start: ");
  const [time, period] = timeComponent.trim().split(" ");
  const [hours, minutes] = time.split(":").map((num) => parseInt(num));

  // Convert to 24-hour format
  let hour24 = hours;
  if (period === "PM" && hours !== 12) {
    hour24 += 12;
  } else if (period === "AM" && hours === 12) {
    hour24 = 0;
  }

  // Get today's date
  const today = new Date();

  // Create a date object with the game time in EST (UTC-5 offset)
  const etDate = new Date(
    Date.UTC(
      today.getFullYear(),
      today.getMonth(),
      today.getDate(),
      hour24 + 5, // EST to UTC offset
      minutes
    )
  );

  // Convert to local time
  const localTime = new Date(etDate);

  // Format the time in local timezone
  const localTimeStr = localTime.toLocaleTimeString([], {
    hour: "numeric",
    minute: "2-digit",
    hour12: true,
  });

  return `Start: ${localTimeStr}`;
};

/**
 * Helper to parse period/time for sorting
 * @param {string} time - Time string (e.g. "1Q 10:44", "Final", "Start: 7:30 PM")
 * @returns {Object} - Object with period, minutes, seconds
 */
export const parseGameTime = (time) => {
  if (time.startsWith("Start:")) return { period: -1, minutes: 0, seconds: 0 };

  // e.g. "1Q 10:44", "OT 5:00", "Final", etc.
  const periodMatch = time.match(/(\d+)Q/) || time.match(/(\d+)OT/);
  const timeMatch = time.match(/(\d+):(\d+)/);

  const period = periodMatch ? parseInt(periodMatch[1]) : 0;
  const minutes = timeMatch ? parseInt(timeMatch[1]) : 0;
  const seconds = timeMatch ? parseInt(timeMatch[2]) : 0;

  return { period, minutes, seconds };
};

/**
 * Sort function for games:
 * - In-progress (higher period first),
 * - then scheduled,
 * - then final
 */
export const sortGames = (a, b) => {
  const timeA = parseGameTime(a.time);
  const timeB = parseGameTime(b.time);

  // Higher period = earlier in the list
  if (timeB.period !== timeA.period) return timeB.period - timeA.period;

  // Then by clock time ascending
  const totalSecondsA = timeA.minutes * 60 + timeA.seconds;
  const totalSecondsB = timeB.minutes * 60 + timeB.seconds;
  return totalSecondsA - totalSecondsB;
};

/**
 * Categorize games into live, scheduled, and completed games
 * @param {Array} games - Array of game objects
 * @returns {Object} - Object with liveGames, scheduledGames, completedGames arrays
 */
export const categorizeGames = (games) => {
  // Live games: not starting with "Start:", not "Final", not starting with "0Q",
  // and specifically include "Halftime"
  const liveGames = games.filter(
    (game) =>
      (game.game_status === 2) ||
      (game.time && 
        ((!game.time.startsWith("Start:") &&
          game.time !== "Final" &&
          !game.time.startsWith("0Q")) ||
          game.time === "Halftime"))
  );

  // Scheduled games
  const scheduledGames = games.filter(
    (game) =>
      (game.game_status === 1) || 
      (game.time && (game.time.startsWith("Start:") || game.time.startsWith("0Q")))
  );

  // Completed games
  const completedGames = games.filter(
    (game) => (game.game_status === 3) || (game.time === "Final")
  );

  return { liveGames, scheduledGames, completedGames };
};

/**
 * Format a date string to local date format
 *
 * @param {string} dateString - ISO date string
 * @returns {string} - Formatted date string
 */
export const formatDate = (dateString) => {
  return new Date(dateString).toLocaleDateString();
};

/**
 * Formats a game time ISO string into a displayable start time
 * @param {string} isoTimeString - ISO time string (e.g., "2025-03-05T01:00:00+00:00")
 * @returns {string} - Formatted time string (e.g., "Start: 8:00 PM")
 */
export const formatGameStartTime = (isoTimeString) => {
  if (!isoTimeString) return "Start: TBD";
  
  try {
    console.log('Formatting time string:', isoTimeString);
    const gameTime = new Date(isoTimeString);
    
    if (isNaN(gameTime.getTime())) {
      console.error('Invalid date from string:', isoTimeString);
      return "Start: TBD";
    }
    
    const timeStr = gameTime.toLocaleTimeString([], {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    });
    
    console.log('Formatted time:', timeStr);
    return `Start: ${timeStr}`;
  } catch (error) {
    console.error("Error formatting game time:", error, isoTimeString);
    return "Start: TBD";
  }
};

================================================
File: utils/pastDateUtils.js
================================================
/**
 * Converts an ISO date string (assumed in EST) to a local time string.
 * If the string already represents a scheduled status (e.g. "Start:" or "0Q")
 * or is "Final", it is returned as-is.
 *
 * @param {string} timeStr - Either an ISO date string (e.g. "2025-02-24T00:00:00")
 *                           or a status string like "Start: 7:30 PM" or "Final".
 * @returns {string} - A formatted time string (e.g. "Start: 7:30 PM") in local timezone.
 */
export const convertToLocalTime = (timeStr) => {
  if (
    timeStr.startsWith("Start:") ||
    timeStr.startsWith("0Q") ||
    timeStr === "Final"
  ) {
    return timeStr;
  }

  // If timeStr is an ISO string (contains "T"), assume it’s in EST (UTC-5).
  if (timeStr.includes("T")) {
    // Append EST offset if needed.
    const date = new Date(timeStr + "-05:00");
    const localTimeStr = date.toLocaleTimeString([], {
      hour: "numeric",
      minute: "2-digit",
      hour12: true,
    });
    return `Start: ${localTimeStr}`;
  }

  return timeStr;
};

/**
 * Normalizes a historical game object.
 * - Creates a top-level `score` property in the format "awayScore - homeScore".
 * - Creates a top-level `time` property using `clock` (or converts `game_time` if missing).
 * - Flattens team objects so UI components receive plain strings.
 *
 * @param {Object} game - A game object from the API.
 * @returns {Object} - A normalized game object.
 */
export const normalizeGame = (game) => {
  // Build a score string from the team scores.
  const awayScore = game.away_team?.score ?? "";
  const homeScore = game.home_team?.score ?? "";
  const score =
    awayScore !== "" && homeScore !== ""
      ? `${awayScore} - ${homeScore}`
      : "";

  // Use the clock if available; otherwise, convert game_time.
  const time = game.clock ? game.clock : convertToLocalTime(game.game_time);

  return {
    ...game,
    score,
    time,
    // Flatten team details for easy consumption in UI components.
    away_team_name: game.away_team?.team_name ?? "",
    away_team_tricode: game.away_team?.team_tricode ?? "",
    home_team_name: game.home_team?.team_name ?? "",
    home_team_tricode: game.home_team?.team_tricode ?? "",
  };
};

/**
 * Normalizes an array of game objects.
 *
 * @param {Array} games - Array of game objects.
 * @returns {Array} - Array of normalized game objects.
 */
export const normalizeGames = (games) => {
  return games.map((game) => normalizeGame(game));
};

/**
 * Sorts games by their game_time in descending order.
 * The most recent game appears first.
 *
 * @param {Object} a - First game object.
 * @param {Object} b - Second game object.
 * @returns {number} - Sorting order.
 */
export const sortGames = (a, b) => {
  return new Date(b.game_time) - new Date(a.game_time);
};

/**
 * Categorizes normalized games into live, scheduled, and completed.
 * - Scheduled games: Those with a time starting with "Start:" or "0Q".
 * - Completed games: Those with a time exactly equal to "Final".
 * - Live games: Any game not falling into the above categories.
 *
 * @param {Array} games - Array of normalized game objects.
 * @returns {Object} - An object with keys { liveGames, scheduledGames, completedGames }.
 */
export const categorizeGames = (games) => {
  const liveGames = games.filter((game) => {
    return (
      !game.time.startsWith("Start:") &&
      !game.time.startsWith("0Q") &&
      game.time !== "Final"
    );
  });

  const scheduledGames = games.filter((game) => {
    return game.time.startsWith("Start:") || game.time.startsWith("0Q");
  });

  const completedGames = games.filter((game) => {
    return game.time === "Final";
  });

  return { liveGames, scheduledGames, completedGames };
};

/**
 * Formats an ISO date string to a local date format.
 *
 * @param {string} dateString - An ISO date string.
 * @returns {string} - A formatted date string (e.g. "2/24/2025").
 */
export const formatDate = (dateString) => {
  return new Date(dateString).toLocaleDateString();
};


