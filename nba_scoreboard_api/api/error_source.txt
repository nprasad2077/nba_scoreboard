Please return the last working version of the code. None of the data is returning in the proper format:


Old working code:


================================================
File: nba_scoreboard_api/api/__init__.py
================================================
# api/__init__.py
"""
NBA Scoreboard API
A FastAPI application for NBA scores and statistics
"""

__version__ = "1.0.0"

================================================
File: nba_scoreboard_api/api/alembic.ini
================================================
# alembic.ini
[alembic]
script_location = alembic
sqlalchemy.url = sqlite:///data/nba_players.db

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

================================================
File: nba_scoreboard_api/api/errors.txt
================================================
Determine what is causing the errors when launching this server:

INFO: ('127.0.0.1', 13338) - "WebSocket /ws" 403
INFO: connection rejected (403 Forbidden)
INFO: connection closed
ERROR:app.services.scoreboard:Error fetching live scoreboard: 1 validation error for TeamGameInfo
team_id
Input should be a valid string [type=string_type, input_value=1610612761, input_type=int]
For further information visit https://errors.pydantic.dev/2.10/v/string_type
ERROR:main:Error in scoreboard update task: 1 validation error for TeamGameInfo
team_id



================================================
File: nba_scoreboard_api/api/main.py
================================================
# main.py
import asyncio
from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.openapi.docs import get_swagger_ui_html, get_redoc_html
import logging

from app.core.config import get_settings
from app.core.database import init_db, get_db, SessionLocal
from app.api.v1.endpoints import router as api_router
from app.services.players import update_player_database
from app.services.standings import update_standings_database

# Import these from your scoreboard service (restores old approach)
from app.services.scoreboard import scoreboard_manager, get_live_scoreboard

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Lifespan events for database initialization and data updates."""
    settings = get_settings()

    # 1) Initialize DB
    init_db()

    # 2) Update player data + standings if not in testing mode
    if not settings.TESTING:
        db = SessionLocal()
        try:
            await update_player_database(db)
            await update_standings_database(db)
        finally:
            db.close()

    # 3) Start background scoreboard task
    scoreboard_task = asyncio.create_task(fetch_scoreboard_updates())

    yield  # Application is running

    # 4) Cleanup
    scoreboard_task.cancel()
    try:
        await scoreboard_task
    except asyncio.CancelledError:
        pass


def create_app() -> FastAPI:
    """Create and configure the FastAPI application."""
    settings = get_settings()

    app = FastAPI(
        title="NBA Scoreboard API",
        description="FastAPI backend for NBA scores and statistics",
        version="1.0.0",
        lifespan=lifespan,
        docs_url=None,  # Disable default /docs
        redoc_url=None,  # Disable default /redoc
    )

    # Configure CORS
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Custom docs endpoints
    @app.get("/docs", include_in_schema=False)
    async def custom_swagger_ui_html():
        return get_swagger_ui_html(
            openapi_url=app.openapi_url,
            title=app.title + " - Swagger UI",
            oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url,
        )

    @app.get("/redoc", include_in_schema=False)
    async def redoc_html():
        return get_redoc_html(
            openapi_url=app.openapi_url,
            title=app.title + " - ReDoc",
        )

    # Include API routers
    app.include_router(api_router, prefix="/api/v1")

    return app


# Replace this function in main.py


async def fetch_scoreboard_updates():
    """
    Background task to periodically fetch the live scoreboard and broadcast updates.
    Only broadcasts when there are meaningful changes to reduce unnecessary network traffic.
    Handles timestamp validation and clock standardization.
    """
    logger.info("Starting scoreboard update background task")
    settings = get_settings()
    
    while True:
        try:
            # Fetch live scoreboard from services/scoreboard.py
            games_response = await get_live_scoreboard()
            
            # Convert to dict and pass to broadcast method which applies
            # clock standardization, change detection, and timestamp validation
            games_data = games_response.model_dump()
            was_broadcast = await scoreboard_manager.broadcast(games_data["games"])
            
            if was_broadcast:
                logger.debug(f"Broadcast scoreboard update with {len(games_data['games'])} games")
                
            # Sleep briefly before the next update (use configured interval)
            await asyncio.sleep(.25)
        except Exception as e:
            logger.error(f"Error in scoreboard update task: {e}")
            # Sleep longer on error
            await asyncio.sleep(5)


app = create_app()

if __name__ == "__main__":
    import uvicorn

    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)


================================================
File: nba_scoreboard_api/api/pyproject.toml
================================================
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "nba-scoreboard-api"
version = "1.0.0"
description = "FastAPI application for NBA scores and statistics"
requires-python = ">=3.9"
dependencies = [
    "fastapi>=0.103.0",
    "uvicorn>=0.23.0",
    "pydantic>=2.3.0",
    "pydantic-settings>=2.0.3",
    "python-dotenv>=1.0.0",
    "SQLAlchemy>=2.0.0",
    "alembic>=1.12.0",
    "nba_api>=1.2.1",
    "python-dateutil>=2.8.2",
    "pytz>=2023.3",
    "httpx>=0.24.1",
    "requests>=2.31.0",
    "pandas>=2.0.0"
]

[tool.pytest.ini_options]
pythonpath = [
    "."
]
addopts = "--cov=app"
testpaths = [
    "tests",
]

[tool.mypy]
python_version = "3.9"
ignore_missing_imports = true
disallow_untyped_defs = true
check_untyped_defs = true

[tool.black]
line-length = 88
target-version = ['py39']
include = '\.pyi?$'

[tool.isort]
profile = "black"
multi_line_output = 3

================================================
File: nba_scoreboard_api/api/alembic/env.py
================================================
# alembic/env.py
import os
import sys
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# Add the parent directory to the Python path
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

# Import your models
from app.models.players import Player
from app.models.standings import TeamStanding
from app.core.database import Base
from app.core.config import get_settings

# This is the Alembic Config object
config = context.config

# Interpret the config file for Python logging
fileConfig(config.config_file_name)

# Set the SQLAlchemy URL in the alembic.ini file
settings = get_settings()
config.set_main_option("sqlalchemy.url", str(settings.SQLALCHEMY_DATABASE_URL))

# Add your model's MetaData object here for 'autogenerate' support
target_metadata = Base.metadata

def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online() -> None:
    """Run migrations in 'online' mode."""
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


================================================
File: nba_scoreboard_api/api/alembic/script.py.mako
================================================
# alembic/script.py.mako
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}

def upgrade() -> None:
    ${upgrades if upgrades else "pass"}

def downgrade() -> None:
    ${downgrades if downgrades else "pass"}

================================================
File: nba_scoreboard_api/api/alembic/versions/2025_02_17_add_games_table.py
================================================
"""add games table

Revision ID: 2025_02_17_games
Revises: 2025_02_17_initial
Create Date: 2025-02-17 12:00:00.000000

"""
from alembic import op
import sqlalchemy as sa
from datetime import datetime

# revision identifiers, used by Alembic.
revision = '2025_02_17_games'
down_revision = '2025_02_17_initial'
branch_labels = None
depends_on = None

def upgrade() -> None:
    # Create games table
    op.create_table(
        'games',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('game_id', sa.String(), nullable=False),
        sa.Column('game_date', sa.DateTime(), nullable=False),
        sa.Column('status', sa.Integer(), nullable=False),
        sa.Column('period', sa.Integer(), default=0),
        sa.Column('clock', sa.String()),
        
        # Home team info
        sa.Column('home_team_id', sa.String(), nullable=False),
        sa.Column('home_team_name', sa.String(), nullable=False),
        sa.Column('home_team_city', sa.String(), nullable=False),
        sa.Column('home_team_tricode', sa.String(), nullable=False),
        sa.Column('home_team_score', sa.Integer(), default=0),
        
        # Away team info
        sa.Column('away_team_id', sa.String(), nullable=False),
        sa.Column('away_team_name', sa.String(), nullable=False),
        sa.Column('away_team_city', sa.String(), nullable=False),
        sa.Column('away_team_tricode', sa.String(), nullable=False),
        sa.Column('away_team_score', sa.Integer(), default=0),
        
        # Venue info
        sa.Column('arena', sa.String()),
        sa.Column('city', sa.String()),
        sa.Column('state', sa.String()),
        sa.Column('country', sa.String()),
        
        # Metadata
        sa.Column('updated_at', sa.DateTime(), nullable=False, 
                 default=datetime.utcnow, onupdate=datetime.utcnow),
        
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('game_id')
    )
    
    # Create indexes
    op.create_index(
        'ix_games_game_id',
        'games',
        ['game_id'],
        unique=True
    )
    op.create_index(
        'ix_games_date_status',
        'games',
        ['game_date', 'status']
    )

def downgrade() -> None:
    # Drop indexes
    op.drop_index('ix_games_date_status', table_name='games')
    op.drop_index('ix_games_game_id', table_name='games')
    
    # Drop games table
    op.drop_table('games')

================================================
File: nba_scoreboard_api/api/alembic/versions/2025_02_17_initial.py
================================================
# alembic/versions/2025_02_17_initial_tables.py
"""initial tables

Revision ID: 2025_02_17_initial
Create Date: 2024-02-17 10:00:00.000000

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic
revision = '2025_02_17_initial'
down_revision = None
branch_labels = None
depends_on = None

def upgrade() -> None:
    # Create players table
    op.create_table(
        'players',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('person_id', sa.Integer(), nullable=True),
        sa.Column('display_name', sa.String(), nullable=True),
        sa.Column('team_name', sa.String(), nullable=True),
        sa.Column('team_abbreviation', sa.String(), nullable=True),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('person_id')
    )
    op.create_index(op.f('ix_players_person_id'), 'players', ['person_id'], unique=True)

    # Create team standings table
    op.create_table(
        'team_standings',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('team_id', sa.Integer(), nullable=True),
        sa.Column('team_city', sa.String(), nullable=True),
        sa.Column('team_name', sa.String(), nullable=True),
        sa.Column('conference', sa.String(), nullable=True),
        sa.Column('division', sa.String(), nullable=True),
        sa.Column('wins', sa.Integer(), nullable=True),
        sa.Column('losses', sa.Integer(), nullable=True),
        sa.Column('win_pct', sa.Float(), nullable=True),
        sa.Column('games_back', sa.Float(), nullable=True),
        sa.Column('conference_rank', sa.Integer(), nullable=True),
        sa.Column('division_rank', sa.Integer(), nullable=True),
        sa.Column('home_record', sa.String(), nullable=True),
        sa.Column('road_record', sa.String(), nullable=True),
        sa.Column('last_ten', sa.String(), nullable=True),
        sa.Column('streak', sa.String(), nullable=True),
        sa.Column('points_pg', sa.Float(), nullable=True),
        sa.Column('opp_points_pg', sa.Float(), nullable=True),
        sa.Column('division_record', sa.String(), nullable=True),
        sa.Column('conference_record', sa.String(), nullable=True),
        sa.Column('vs_east', sa.String(), nullable=True),
        sa.Column('vs_west', sa.String(), nullable=True),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('team_id')
    )
    op.create_index(op.f('ix_team_standings_team_id'), 'team_standings', ['team_id'], unique=True)

def downgrade() -> None:
    # Drop team standings table
    op.drop_index(op.f('ix_team_standings_team_id'), table_name='team_standings')
    op.drop_table('team_standings')
    
    # Drop players table
    op.drop_index(op.f('ix_players_person_id'), table_name='players')
    op.drop_table('players')

================================================
File: nba_scoreboard_api/api/app/api/v1/__init__.py
================================================
# app/api/v1/__init__.py
from fastapi import APIRouter
from app.api.v1.endpoints import players, scoreboard, standings

# Create the main v1 router
router = APIRouter()

# Include all endpoint routers
router.include_router(
    players.router,
    prefix="/players",
    tags=["players"]
)

router.include_router(
    scoreboard.router,
    prefix="/scoreboard",
    tags=["scoreboard"]
)

router.include_router(
    standings.router,
    prefix="/standings",
    tags=["standings"]
)

================================================
File: nba_scoreboard_api/api/app/api/v1/endpoints/__init__.py
================================================
# app/api/v1/endpoints/__init__.py
from fastapi import APIRouter

from app.api.v1.endpoints import players, scoreboard, standings

router = APIRouter()

router.include_router(players.router, prefix="/players", tags=["players"])
router.include_router(scoreboard.router, prefix="/scoreboard", tags=["scoreboard"])
router.include_router(standings.router, prefix="/standings", tags=["standings"])

================================================
File: nba_scoreboard_api/api/app/api/v1/endpoints/players.py
================================================
# app/api/v1/endpoints/players.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List

from app.core.database import get_db
from app.services.players import (
    get_player_recent_games,
    search_players,
    update_player_database
)
from app.schemas.players import PlayerBase, PlayerStats

router = APIRouter()

@router.get("/search/", response_model=List[PlayerBase])
async def search_players_route(
    query: str = Query(..., min_length=2),
    db: Session = Depends(get_db)
):
    """
    Search for players by name.
    
    Args:
        query: Search string (minimum 2 characters)
        db: Database session
    
    Returns:
        List of matching players
    """
    return await search_players(db, query)

@router.get("/{player_id}/games", response_model=PlayerStats)
async def get_player_games(
    player_id: int,
    last_n_games: int = Query(default=10, ge=1, le=82),
    db: Session = Depends(get_db)
):
    """
    Get a player's recent game statistics.
    
    Args:
        player_id: The NBA person ID of the player
        last_n_games: Number of recent games to return (1-82)
        db: Database session
    
    Returns:
        Player info and game statistics
    
    Raises:
        HTTPException: If player is not found
    """
    result = await get_player_recent_games(db, player_id, last_n_games)
    if result is None:
        raise HTTPException(status_code=404, detail="Player not found")
    return result

@router.post("/update", status_code=200)
async def update_players(db: Session = Depends(get_db)):
    """
    Update the players database with current NBA players.
    
    Args:
        db: Database session
    
    Returns:
        Success message
    """
    await update_player_database(db)
    return {"message": "Players database updated successfully"}

================================================
File: nba_scoreboard_api/api/app/api/v1/endpoints/scoreboard.py
================================================
# app/api/v1/endpoints/scoreboard.py
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, HTTPException, Query
import asyncio
from typing import Optional
from datetime import datetime, timedelta
import logging

from app.services.scoreboard import (
    get_box_score_fixed,  # Import the fixed version 
    get_past_scoreboard,
    scoreboard_manager,
    playbyplay_manager
)
from app.schemas.scoreboard import GameBoxScore

router = APIRouter()
logger = logging.getLogger(__name__)

@router.websocket("/ws")
async def scoreboard_websocket(websocket: WebSocket):
    """
    WebSocket endpoint for live scoreboard updates.
    Streams game scores and status updates to connected clients.
    """
    await scoreboard_manager.connect(websocket)
    try:
        # Send initial scoreboard data
        await scoreboard_manager.send_current_games(websocket)
        
        # Keep connection alive and handle client messages
        while True:
            await websocket.receive_text()
            
    except WebSocketDisconnect:
        await scoreboard_manager.disconnect(websocket)
    except Exception as e:
        logger.error(f"WebSocket error: {e}")
        await scoreboard_manager.disconnect(websocket)

@router.websocket("/ws/playbyplay/{game_id}")
async def playbyplay_websocket(websocket: WebSocket, game_id: str):
    """
    WebSocket endpoint for live play-by-play updates for a specific game.
    """
    await playbyplay_manager.connect(websocket, game_id)
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        await playbyplay_manager.disconnect(websocket, game_id)
    except Exception as e:
        logger.error(f"[PlayByPlay] WebSocket error: {e}")
        await playbyplay_manager.disconnect(websocket, game_id)

@router.get("/past")
async def get_past_games(
    date: Optional[str] = Query(None, description="Date in YYYY-MM-DD format")
):
    """
    Get scoreboard data for past games.
    
    Args:
        date: Optional date string (YYYY-MM-DD). Defaults to yesterday if not provided.
    
    Returns:
        List of game results for the specified date
    """
    if date is None:
        # Default to yesterday
        date = (datetime.now() - timedelta(days=1)).strftime("%Y-%m-%d")
    return await get_past_scoreboard(date)

@router.get("/boxscore/{game_id}", response_model=GameBoxScore)
async def get_game_boxscore(game_id: str):
    """
    Get detailed box score for a specific game.
    
    Args:
        game_id: NBA game ID
    
    Returns:
        Detailed game statistics including player stats
    
    Raises:
        HTTPException: If box score is not found
    """
    try:
        # Use the fixed implementation
        result = await get_box_score_fixed(game_id)
        return result
    except Exception as e:
        logger.error(f"Error fetching box score: {e}")
        raise HTTPException(status_code=500, detail=str(e))

================================================
File: nba_scoreboard_api/api/app/api/v1/endpoints/standings.py
================================================
# app/api/v1/endpoints/standings.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.core.database import get_db
from app.services.standings import (
    get_conference_standings,
    get_division_standings,
    update_standings_database
)
from app.schemas.standings import StandingsResponse

router = APIRouter()

@router.get("/conference/{conference}", response_model=List[StandingsResponse])
async def get_conference_standings_route(
    conference: str,
    db: Session = Depends(get_db)
):
    """
    Get standings for a specific conference (East or West).
    
    Args:
        conference: Conference name ('East' or 'West')
        db: Database session
    
    Returns:
        List of team standings for the specified conference
    
    Raises:
        HTTPException: If conference is invalid or no standings found
    """
    if conference.lower() not in ['east', 'west']:
        raise HTTPException(
            status_code=400,
            detail="Conference must be 'East' or 'West'"
        )
    
    standings = await get_conference_standings(db, conference)
    if not standings:
        raise HTTPException(
            status_code=404,
            detail=f"No standings found for {conference} conference"
        )
    return standings

@router.get("/division/{division}", response_model=List[StandingsResponse])
async def get_division_standings_route(
    division: str,
    db: Session = Depends(get_db)
):
    """
    Get standings for a specific division.
    
    Args:
        division: Division name (e.g., 'Atlantic', 'Central', etc.)
        db: Database session
    
    Returns:
        List of team standings for the specified division
    
    Raises:
        HTTPException: If division is invalid or no standings found
    """
    valid_divisions = [
        'atlantic', 'central', 'southeast',
        'northwest', 'pacific', 'southwest'
    ]
    
    if division.lower() not in valid_divisions:
        raise HTTPException(
            status_code=400,
            detail=f"Division must be one of: {', '.join(valid_divisions)}"
        )
    
    standings = await get_division_standings(db, division)
    if not standings:
        raise HTTPException(
            status_code=404,
            detail=f"No standings found for {division} division"
        )
    return standings

@router.post("/update", status_code=200)
async def update_standings(db: Session = Depends(get_db)):
    """
    Update the standings database with current NBA standings.
    
    Args:
        db: Database session
    
    Returns:
        Success message
    """
    await update_standings_database(db)
    return {"message": "Standings database updated successfully"}

================================================
File: nba_scoreboard_api/api/app/core/config.py
================================================
# app/core/config.py
from functools import lru_cache
from typing import List, Union
from pydantic_settings import BaseSettings
from pathlib import Path

# Get project root directory and env file path
PROJECT_ROOT = Path(__file__).parent.parent.parent
ENV_FILE = PROJECT_ROOT / ".env"

class Settings(BaseSettings):
    # API Settings
    API_V1_STR: str = "/api/v1"
    PROJECT_NAME: str = "NBA Scoreboard API"
    VERSION: str = "1.0.0"
    DEBUG: bool = False
    
    # Database
    PROJECT_ROOT: Path = PROJECT_ROOT
    DB_PATH: Path = PROJECT_ROOT / "data" / "nba_players.db"
    SQLALCHEMY_DATABASE_URL: str = f"sqlite:///{DB_PATH}"
    
    # NBA API Settings
    NBA_API_DELAY: float = 1.0  # Delay between NBA API calls
    NBA_SEASON: str = "2024-25"
    NBA_LEAGUE_ID: str = "00"
    
    # CORS - Default to allow all
    CORS_ORIGINS_STR: str = "*"
    
    # WebSocket Settings
    WS_UPDATE_INTERVAL: float = 1.0  # Seconds between scoreboard updates
    WS_HEARTBEAT_INTERVAL: float = 30.0  # Seconds between heartbeat messages
    
    # Testing
    TESTING: bool = False

    @property
    def CORS_ORIGINS(self) -> List[str]:
        """Parse CORS_ORIGINS_STR into a list."""
        if self.CORS_ORIGINS_STR == "*":
            return ["*"]
        return [origin.strip() for origin in self.CORS_ORIGINS_STR.split(",")]
    
    class Config:
        env_file = str(ENV_FILE)
        case_sensitive = True

@lru_cache()
def get_settings() -> Settings:
    """Return cached settings instance."""
    if not ENV_FILE.exists():
        raise FileNotFoundError(
            f"Environment file not found at {ENV_FILE}. "
            f"Please create one from .env.example"
        )
    return Settings()

================================================
File: nba_scoreboard_api/api/app/core/database.py
================================================
# app/core/database.py
import logging
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session, DeclarativeBase
from pathlib import Path
import subprocess

from app.core.config import get_settings

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

settings = get_settings()

# Ensure the data directory exists
settings.DB_PATH.parent.mkdir(parents=True, exist_ok=True)

# Create engine
engine = create_engine(
    settings.SQLALCHEMY_DATABASE_URL,
    connect_args={"check_same_thread": False}  # Needed for SQLite
)

SessionLocal = sessionmaker(bind=engine, autocommit=False, autoflush=False)

class Base(DeclarativeBase):
    pass

def get_db() -> Session:
    """Dependency that provides a DB session."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def init_db() -> None:
    """Initialize the database by creating all tables."""
    try:
        # Create tables using SQLAlchemy
        # Base.metadata.create_all(bind=engine)
        logger.info("Database tables created successfully")
        
        # Run migrations using alembic CLI
        try:
            subprocess.run(["alembic", "upgrade", "head"], check=True)
            logger.info("Database migrations completed successfully")
        except subprocess.CalledProcessError as e:
            logger.error(f"Error running migrations: {e}")
            # Continue even if migrations fail, as tables are created
            
    except Exception as e:
        logger.error(f"Error initializing database: {e}")
        raise

================================================
File: nba_scoreboard_api/api/app/models/__init__.py
================================================
# app/models/__init__.py
from app.models.players import Player
from app.models.standings import TeamStanding

__all__ = [
    "Player",
    "TeamStanding"
]

================================================
File: nba_scoreboard_api/api/app/models/players.py
================================================
# app/models/players.py
from sqlalchemy import Column, Integer, String, UniqueConstraint, Index
from sqlalchemy.orm import relationship
from app.core.database import Base

class Player(Base):
    """SQLAlchemy model for NBA players."""
    __tablename__ = "players"

    # Primary key
    id = Column(Integer, primary_key=True)
    
    # Player information
    person_id = Column(
        Integer,
        unique=True,
        index=True,
        nullable=False,
        comment="NBA.com person ID"
    )
    display_name = Column(
        String,
        nullable=False,
        comment="Player's full name"
    )
    team_name = Column(
        String,
        nullable=False,
        comment="Current team name"
    )
    team_abbreviation = Column(
        String,
        nullable=False,
        comment="Current team abbreviation"
    )

    # Indexes and constraints
    __table_args__ = (
        UniqueConstraint('person_id', name='uq_player_person_id'),
        Index('ix_player_display_name', 'display_name'),
        Index('ix_player_team', 'team_name', 'team_abbreviation'),
    )

    def __repr__(self):
        """String representation of the Player model."""
        return f"<Player(id={self.id}, name='{self.display_name}', team='{self.team_abbreviation}')>"

================================================
File: nba_scoreboard_api/api/app/models/scoreboard.py
================================================
# app/models/scoreboard.py
from sqlalchemy import Column, Integer, String, DateTime, Float, ForeignKey, Index
from sqlalchemy.orm import relationship
from app.core.database import Base
from datetime import datetime

class Game(Base):
    """SQLAlchemy model for NBA games."""
    __tablename__ = "games"

    id = Column(Integer, primary_key=True)
    game_id = Column(String, unique=True, index=True, nullable=False)
    game_date = Column(DateTime, nullable=False)
    status = Column(Integer, nullable=False, comment="1=Scheduled, 2=In Progress, 3=Final")
    period = Column(Integer, default=0)
    clock = Column(String)
    
    # Teams
    home_team_id = Column(String, nullable=False)
    home_team_name = Column(String, nullable=False)
    home_team_city = Column(String, nullable=False)
    home_team_tricode = Column(String, nullable=False)
    home_team_score = Column(Integer, default=0)
    
    away_team_id = Column(String, nullable=False)
    away_team_name = Column(String, nullable=False)
    away_team_city = Column(String, nullable=False)
    away_team_tricode = Column(String, nullable=False)
    away_team_score = Column(Integer, default=0)

    # Metadata
    arena = Column(String)
    city = Column(String)
    state = Column(String)
    country = Column(String)
    
    # Last updated timestamp
    updated_at = Column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        nullable=False
    )

    __table_args__ = (
        Index('ix_games_date_status', 'game_date', 'status'),
    )

    def __repr__(self):
        return f"<Game {self.game_id}: {self.away_team_tricode} @ {self.home_team_tricode}>"

================================================
File: nba_scoreboard_api/api/app/models/standings.py
================================================
# app/models/standings.py
from sqlalchemy import Column, Integer, String, Float, UniqueConstraint, Index
from sqlalchemy.orm import relationship
from app.core.database import Base

class TeamStanding(Base):
    """SQLAlchemy model for NBA team standings."""
    __tablename__ = "team_standings"

    # Primary key
    id = Column(Integer, primary_key=True)
    
    # Team identification
    team_id = Column(
        Integer,
        unique=True,
        index=True,
        nullable=False,
        comment="NBA.com team ID"
    )
    team_city = Column(
        String,
        nullable=False,
        comment="Team city"
    )
    team_name = Column(
        String,
        nullable=False,
        comment="Team name"
    )

    # Conference and division
    conference = Column(
        String,
        nullable=False,
        comment="Conference (East/West)"
    )
    division = Column(
        String,
        nullable=False,
        comment="Division name"
    )

    # Record
    wins = Column(
        Integer,
        nullable=False,
        default=0,
        comment="Number of wins"
    )
    losses = Column(
        Integer,
        nullable=False,
        default=0,
        comment="Number of losses"
    )
    win_pct = Column(
        Float,
        nullable=False,
        default=0.0,
        comment="Winning percentage"
    )
    games_back = Column(
        Float,
        nullable=False,
        default=0.0,
        comment="Games behind conference leader"
    )

    # Rankings
    conference_rank = Column(
        Integer,
        nullable=False,
        comment="Rank in conference"
    )
    division_rank = Column(
        Integer,
        nullable=False,
        comment="Rank in division"
    )

    # Additional records
    home_record = Column(
        String,
        nullable=False,
        default="0-0",
        comment="Home record (W-L)"
    )
    road_record = Column(
        String,
        nullable=False,
        default="0-0",
        comment="Road record (W-L)"
    )
    last_ten = Column(
        String,
        nullable=False,
        default="0-0",
        comment="Record in last 10 games"
    )
    streak = Column(
        String,
        nullable=False,
        default="",
        comment="Current streak"
    )

    # Statistics
    points_pg = Column(
        Float,
        nullable=False,
        default=0.0,
        comment="Points per game"
    )
    opp_points_pg = Column(
        Float,
        nullable=False,
        default=0.0,
        comment="Opponent points per game"
    )

    # Record breakdowns
    division_record = Column(
        String,
        nullable=False,
        default="0-0",
        comment="Record against division"
    )
    conference_record = Column(
        String,
        nullable=False,
        default="0-0",
        comment="Record against conference"
    )
    vs_east = Column(
        String,
        nullable=False,
        default="0-0",
        comment="Record against Eastern Conference"
    )
    vs_west = Column(
        String,
        nullable=False,
        default="0-0",
        comment="Record against Western Conference"
    )

    # Indexes and constraints
    __table_args__ = (
        UniqueConstraint('team_id', name='uq_team_team_id'),
        Index('ix_team_conference', 'conference'),
        Index('ix_team_division', 'division'),
        Index('ix_team_conference_rank', 'conference', 'conference_rank'),
        Index('ix_team_division_rank', 'division', 'division_rank'),
    )

    def __repr__(self):
        """String representation of the TeamStanding model."""
        return f"<TeamStanding(id={self.id}, team='{self.team_name}', record='{self.wins}-{self.losses}')>"

================================================
File: nba_scoreboard_api/api/app/schemas/__init__.py
================================================
# app/schemas/__init__.py
from app.schemas.players import PlayerBase, GameStats, PlayerStats
from app.schemas.standings import StandingsResponse

__all__ = [
    "PlayerBase",
    "GameStats",
    "PlayerStats",
    "StandingsResponse"
]

================================================
File: nba_scoreboard_api/api/app/schemas/players.py
================================================
# app/schemas/players.py
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import date

class PlayerBase(BaseModel):
    """Base player model containing core player information."""
    person_id: int = Field(..., description="NBA.com person ID")
    display_name: str = Field(..., description="Player's full name")
    team_name: str = Field(..., description="Current team name")
    team_abbreviation: str = Field(..., description="Current team abbreviation")

    class Config:
        from_attributes = True

class GameStats(BaseModel):
    """Model for player game statistics."""
    game_date: str = Field(..., description="Date of the game")
    matchup: str = Field(..., description="Game matchup (e.g., 'LAL vs. BOS')")
    wl: str = Field(..., description="Win/Loss result")
    min: float = Field(..., description="Minutes played")
    pts: int = Field(..., description="Points scored")
    fgm: int = Field(..., description="Field goals made")
    fga: int = Field(..., description="Field goals attempted")
    fg_pct: float = Field(..., description="Field goal percentage")
    fg3m: int = Field(..., description="Three pointers made")
    fg3a: int = Field(..., description="Three pointers attempted")
    fg3_pct: float = Field(..., description="Three point percentage")
    ftm: int = Field(..., description="Free throws made")
    fta: int = Field(..., description="Free throws attempted")
    ft_pct: float = Field(..., description="Free throw percentage")
    oreb: int = Field(..., description="Offensive rebounds")
    dreb: int = Field(..., description="Defensive rebounds")
    reb: int = Field(..., description="Total rebounds")
    ast: int = Field(..., description="Assists")
    stl: int = Field(..., description="Steals")
    blk: int = Field(..., description="Blocks")
    tov: int = Field(..., description="Turnovers")
    pf: int = Field(..., description="Personal fouls")
    plus_minus: int = Field(..., description="Plus/minus")

class PlayerStats(BaseModel):
    """Combined model for player info and game statistics."""
    player_info: PlayerBase = Field(..., description="Player's basic information")
    games: List[GameStats] = Field(..., description="List of game statistics")

class PlayerSearch(BaseModel):
    """Model for player search parameters."""
    query: str = Field(..., min_length=2, description="Search query (minimum 2 characters)")

class PlayerGamesParams(BaseModel):
    """Model for player games query parameters."""
    player_id: int = Field(..., description="NBA.com person ID")
    last_n_games: Optional[int] = Field(
        10, 
        ge=1, 
        le=82, 
        description="Number of recent games to return (1-82)"
    )

================================================
File: nba_scoreboard_api/api/app/schemas/scoreboard.py
================================================
# app/schemas/scoreboard.py
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from datetime import datetime

# Team related models for scoreboard display
class TeamGameInfo(BaseModel):
    """Basic team information for a game."""
    team_id: str = Field(..., description="NBA team ID")
    team_name: str = Field(..., description="Team name")
    team_city: str = Field(..., description="Team city")
    team_tricode: str = Field(..., description="Three-letter team code")
    score: int = Field(default=0, description="Current score")

class GameBrief(BaseModel):
    """Brief game information for scoreboard display."""
    game_id: str = Field(..., description="NBA game ID")
    game_status: int = Field(..., description="1=Scheduled, 2=In Progress, 3=Final")
    away_team: TeamGameInfo
    home_team: TeamGameInfo
    period: int = Field(default=0, description="Current period")
    clock: Optional[str] = Field(None, description="Game clock in ISO 8601 duration format")
    game_time: datetime = Field(..., description="Scheduled game time (UTC)")

class GameDetail(GameBrief):
    """Detailed game information including venue."""
    arena: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    country: Optional[str] = None

class ScoreboardResponse(BaseModel):
    """Response model for scoreboard endpoint."""
    games: List[GameBrief]
    total_games: int
    current_timestamp: datetime = Field(default_factory=datetime.utcnow)

# Box score related models
class PlayerStatistics(BaseModel):
    """Player game statistics."""
    minutes: str = Field(default="0:00")
    points: int = Field(default=0)
    assists: int = Field(default=0)
    reboundsTotal: int = Field(default=0)
    reboundsDefensive: int = Field(default=0)
    reboundsOffensive: int = Field(default=0)
    steals: int = Field(default=0)
    blocks: int = Field(default=0)
    turnovers: int = Field(default=0)
    foulsPersonal: int = Field(default=0)
    fieldGoalsMade: int = Field(default=0)
    fieldGoalsAttempted: int = Field(default=0)
    fieldGoalsPercentage: float = Field(default=0.0)
    threePointersMade: int = Field(default=0)
    threePointersAttempted: int = Field(default=0)
    threePointersPercentage: float = Field(default=0.0)
    freeThrowsMade: int = Field(default=0)
    freeThrowsAttempted: int = Field(default=0)
    freeThrowsPercentage: float = Field(default=0.0)
    plusMinusPoints: int = Field(default=0)

class PlayerData(BaseModel):
    """Player data model matching the original implementation."""
    name: str = Field(default="")
    position: str = Field(default="")
    starter: bool = Field(default=False)
    oncourt: bool = Field(default=False)
    jerseyNum: str = Field(default="")
    status: str = Field(default="")
    statistics: PlayerStatistics = Field(default_factory=PlayerStatistics)

class PlayerBoxScore(BaseModel):
    """Player box score information."""
    player_id: str = Field(default="")
    name: str = Field(default="")
    position: str = Field(default="")
    starter: bool = Field(default=False)
    statistics: PlayerStatistics = Field(default_factory=PlayerStatistics)

class TeamBoxScore(BaseModel):
    """Team box score information."""
    team_id: str = Field(default="")
    team_name: str = Field(default="")
    team_city: str = Field(default="")
    team_tricode: str = Field(default="")
    players: List[PlayerBoxScore] = Field(default_factory=list)

class GameBoxScore(BaseModel):
    """Complete box score for a game."""
    game_id: str
    status: int = Field(default=1)
    period: int = Field(default=0)
    clock: Optional[str] = None
    home_team: TeamBoxScore
    away_team: TeamBoxScore

    class Config:
        from_attributes = True
        populate_by_name = True

class PlayByPlayEvent(BaseModel):
    """Play-by-play event information."""
    event_id: str = Field(default="")
    clock: str = Field(default="")
    period: int = Field(default=0)
    description: str = Field(default="")
    score: Optional[str] = None
    team_tricode: Optional[str] = None
    player_name: Optional[str] = None

class PlayByPlayResponse(BaseModel):
    """Response model for play-by-play endpoint."""
    game_id: str
    period: int = Field(default=0)
    clock: Optional[str] = None
    events: List[PlayByPlayEvent] = Field(default_factory=list)

================================================
File: nba_scoreboard_api/api/app/schemas/standings.py
================================================
# app/schemas/standings.py
from pydantic import BaseModel, Field
from typing import List
from enum import Enum

class Conference(str, Enum):
    """Enumeration of NBA conferences."""
    EAST = "East"
    WEST = "West"

class Division(str, Enum):
    """Enumeration of NBA divisions."""
    ATLANTIC = "Atlantic"
    CENTRAL = "Central"
    SOUTHEAST = "Southeast"
    NORTHWEST = "Northwest"
    PACIFIC = "Pacific"
    SOUTHWEST = "Southwest"

class StandingsResponse(BaseModel):
    """Model for team standings information."""
    team_id: int = Field(..., description="NBA.com team ID")
    team_city: str = Field(..., description="Team city")
    team_name: str = Field(..., description="Team name")
    conference: str = Field(..., description="Conference (East/West)")
    division: str = Field(..., description="Division name")
    wins: int = Field(..., description="Number of wins")
    losses: int = Field(..., description="Number of losses")
    win_pct: float = Field(..., description="Winning percentage")
    games_back: float = Field(..., description="Games behind conference leader")
    conference_rank: int = Field(..., description="Rank in conference")
    division_rank: int = Field(..., description="Rank in division")
    home_record: str = Field(..., description="Home record (W-L)")
    road_record: str = Field(..., description="Road record (W-L)")
    last_ten: str = Field(..., description="Record in last 10 games")
    streak: str = Field(..., description="Current streak")
    points_pg: float = Field(..., description="Points per game")
    opp_points_pg: float = Field(..., description="Opponent points per game")
    division_record: str = Field(..., description="Record against division")
    conference_record: str = Field(..., description="Record against conference")
    vs_east: str = Field(..., description="Record against Eastern Conference")
    vs_west: str = Field(..., description="Record against Western Conference")

    class Config:
        from_attributes = True

class ConferenceStandings(BaseModel):
    """Model for conference standings response."""
    conference: Conference
    standings: List[StandingsResponse]

class DivisionStandings(BaseModel):
    """Model for division standings response."""
    division: Division
    standings: List[StandingsResponse]

class StandingsUpdate(BaseModel):
    """Model for standings update response."""
    message: str = Field(..., description="Update status message")
    updated_teams: int = Field(..., description="Number of teams updated")

================================================
File: nba_scoreboard_api/api/app/services/__init__.py
================================================
# app/services/__init__.py
from app.services.players import get_player_recent_games, search_players, update_player_database
from app.services.standings import get_conference_standings, get_division_standings, update_standings_database

__all__ = [
    "get_player_recent_games",
    "search_players",
    "update_player_database",
    "get_conference_standings",
    "get_division_standings",
    "update_standings_database"
]

================================================
File: nba_scoreboard_api/api/app/services/players.py
================================================
# app/services/players.py
import logging
from sqlalchemy.orm import Session
from nba_api.stats.endpoints import commonallplayers, playergamelogs
from typing import Optional, Tuple, Any

from app.models.players import Player
from app.schemas.players import PlayerStats, PlayerBase, GameStats

# Configure logging
logger = logging.getLogger(__name__)

async def update_player_database(db: Session) -> None:
    """
    Update the SQLite database with current NBA players.
    
    Args:
        db: Database session
    
    Raises:
        Exception: If there's an error updating the database
    """
    try:
        # Get all current NBA players
        all_players = commonallplayers.CommonAllPlayers(
            is_only_current_season=1,
            league_id='00',
            season='2024-25'
        )
        df_players = all_players.common_all_players.get_data_frame()
        
        try:
            # Clear existing players
            db.query(Player).delete()
            
            # Add new players
            for _, row in df_players.iterrows():
                db_player = Player(
                    person_id=row['PERSON_ID'],
                    display_name=row['DISPLAY_FIRST_LAST'],
                    team_name=row['TEAM_NAME'],
                    team_abbreviation=row['TEAM_ABBREVIATION']
                )
                db.add(db_player)
            
            db.commit()
            logger.info("Successfully updated player database")
            
        except Exception as e:
            db.rollback()
            logger.error(f"Error updating database: {e}")
            raise
            
    except Exception as e:
        logger.error(f"Error fetching player data: {e}")
        raise

async def get_player_recent_games(
    db: Session,
    player_id: int,
    last_n_games: int = 10
) -> Optional[PlayerStats]:
    """
    Get recent games for a specific player.
    
    Args:
        db: Database session
        player_id: NBA.com person ID
        last_n_games: Number of recent games to return (default: 10)
    
    Returns:
        PlayerStats object containing player info and game statistics,
        or None if player not found
    """
    # Get player from database
    player = db.query(Player).filter(Player.person_id == player_id).first()
    if not player:
        return None
    
    try:
        # Fetch game logs from NBA API
        logs = playergamelogs.PlayerGameLogs(
            player_id_nullable=player_id,
            season_nullable="2024-25",
            season_type_nullable="Regular Season",
            last_n_games_nullable=last_n_games
        )
        df_games = logs.get_data_frames()[0]
        
        # Convert player to PlayerBase model
        player_info = PlayerBase(
            person_id=player.person_id,
            display_name=player.display_name,
            team_name=player.team_name,
            team_abbreviation=player.team_abbreviation
        )
        
        # Convert game logs to GameStats models
        games = []
        for _, game in df_games.iterrows():
            game_stats = GameStats(
                game_date=game["GAME_DATE"],
                matchup=game["MATCHUP"],
                wl=game["WL"],
                min=float(game["MIN"]) if game["MIN"] else 0.0,
                pts=game["PTS"],
                fgm=game["FGM"],
                fga=game["FGA"],
                fg_pct=game["FG_PCT"],
                fg3m=game["FG3M"],
                fg3a=game["FG3A"],
                fg3_pct=game["FG3_PCT"],
                ftm=game["FTM"],
                fta=game["FTA"],
                ft_pct=game["FT_PCT"],
                oreb=game["OREB"],
                dreb=game["DREB"],
                reb=game["REB"],
                ast=game["AST"],
                stl=game["STL"],
                blk=game["BLK"],
                tov=game["TOV"],
                pf=game["PF"],
                plus_minus=game["PLUS_MINUS"]
            )
            games.append(game_stats)
        
        return PlayerStats(player_info=player_info, games=games)
        
    except Exception as e:
        logger.error(f"Error fetching game logs for player {player_id}: {e}")
        raise

async def search_players(db: Session, query: str) -> list[Player]:
    """
    Search for players by name.
    
    Args:
        db: Database session
        query: Search string
    
    Returns:
        List of matching Player objects
    """
    search_query = f"%{query}%"
    return db.query(Player).filter(Player.display_name.ilike(search_query)).all()

================================================
File: nba_scoreboard_api/api/app/services/scoreboard.py
================================================
# File: app/services/scoreboard.py
import logging
import asyncio
import re
import time
from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any, Set
from fastapi import WebSocket
from nba_api.live.nba.endpoints import scoreboard, boxscore, playbyplay
import pytz
from dateutil import parser
import json
import copy

from app.models.scoreboard import Game
from app.schemas.scoreboard import (
    GameBrief,
    GameDetail,
    ScoreboardResponse,
    GameBoxScore,
    PlayByPlayEvent,
    PlayByPlayResponse,
    TeamGameInfo,
    TeamBoxScore,
    PlayerBoxScore,
    PlayerStatistics,
)

logger = logging.getLogger(__name__)


# To add to app/services/scoreboard.py


async def get_box_score_fixed(game_id: str):
    """
    Fixed implementation that matches the schema fields correctly.

    This implementation follows the corrected field names in our schema:
    - game_id instead of gameId
    - team_id instead of teamId
    - etc.
    """
    try:
        logger.info(f"Fetching box score for game ID: {game_id}")

        # Create BoxScore object from NBA API
        b = boxscore.BoxScore(game_id)

        # Process home team players
        home_players = []
        for player in b.home_team_player_stats.get_dict() or []:
            if isinstance(player, dict):
                # Extract statistics safely
                stats_dict = player.get("statistics", {}) or {}

                home_players.append(
                    PlayerBoxScore(
                        player_id=str(player.get("personId", "")),
                        name=player.get("name", ""),
                        position=player.get("position", ""),
                        starter=player.get("starter", False),
                        statistics=PlayerStatistics(**stats_dict),
                    )
                )

        # Process away team players
        away_players = []
        for player in b.away_team_player_stats.get_dict() or []:
            if isinstance(player, dict):
                # Extract statistics safely
                stats_dict = player.get("statistics", {}) or {}

                away_players.append(
                    PlayerBoxScore(
                        player_id=str(player.get("personId", "")),
                        name=player.get("name", ""),
                        position=player.get("position", ""),
                        starter=player.get("starter", False),
                        statistics=PlayerStatistics(**stats_dict),
                    )
                )

        # Get team stats
        home_team_stats = b.home_team_stats.get_dict() or {}
        away_team_stats = b.away_team_stats.get_dict() or {}

        # Get game metadata
        game_data = b.get_dict() or {}
        game_status = game_data.get("gameStatus", 1)
        game_period = game_data.get("period", 0)
        game_clock = game_data.get("gameClock")

        # Construct the final response using field names matching the schema
        return GameBoxScore(
            game_id=game_id,
            status=game_status,
            period=game_period,
            clock=game_clock,
            home_team=TeamBoxScore(
                team_id=str(home_team_stats.get("teamId", "")),
                team_name=home_team_stats.get("teamName", ""),
                team_city=home_team_stats.get("teamCity", ""),
                team_tricode=home_team_stats.get("teamTricode", ""),
                players=home_players,
            ),
            away_team=TeamBoxScore(
                team_id=str(away_team_stats.get("teamId", "")),
                team_name=away_team_stats.get("teamName", ""),
                team_city=away_team_stats.get("teamCity", ""),
                team_tricode=away_team_stats.get("teamTricode", ""),
                players=away_players,
            ),
        )

    except Exception as e:
        logger.error(f"Error in get_box_score_fixed for game {game_id}: {e}")
        # Return empty response with correct field names
        return GameBoxScore(
            game_id=game_id,
            status=1,
            period=0,
            clock=None,
            home_team=TeamBoxScore(
                team_id="",
                team_name="",
                team_city="",
                team_tricode="",
                players=[],
            ),
            away_team=TeamBoxScore(
                team_id="",
                team_name="",
                team_city="",
                team_tricode="",
                players=[],
            ),
        )


def standardize_game_clocks(games_data: List[Dict]) -> List[Dict]:
    """
    Standardize game clocks to a consistent format and filter out invalid formats.

    Args:
        games_data: List of game data dictionaries

    Returns:
        List of games with standardized clock formats
    """
    standardized_games = []

    for game in games_data:
        # Create a copy to avoid modifying the original
        game_copy = copy.deepcopy(game)

        # Process the clock field
        clock = game_copy.get("clock", "")

        # Handle various clock formats
        if clock is None or clock.strip() in ("", " "):
            # Set empty/blank clocks to None
            game_copy["clock"] = None
        elif clock.startswith("PT") and "M" in clock and "S" in clock:
            # ISO 8601 Duration format - keep as is
            pass
        elif re.match(r"\d+:\d+\s*", clock):
            # Convert "5:06 " format to ISO 8601 duration format
            try:
                parts = clock.strip().split(":")
                minutes = int(parts[0])
                seconds = int(parts[1])
                game_copy["clock"] = f"PT{minutes:02d}M{seconds:02d}.00S"
            except (ValueError, IndexError):
                # If conversion fails, set to None
                game_copy["clock"] = None
        else:
            # Unknown format, set to None
            game_copy["clock"] = None

        standardized_games.append(game_copy)

    return standardized_games


def parse_game_clock(clock_str: Optional[str]) -> Optional[float]:
    """
    Parse the game clock string into seconds remaining.

    Args:
        clock_str: Game clock string in ISO 8601 duration format (e.g., "PT09M47.00S")

    Returns:
        Seconds remaining in the period, or None if parsing fails
    """
    if not clock_str:
        return None

    try:
        # Parse the PT12M00.00S format
        match = re.match(r"PT(\d+)M(\d+(?:\.\d+)?)S", clock_str)
        if match:
            minutes = int(match.group(1))
            seconds = float(match.group(2))
            return minutes * 60 + seconds
    except Exception:
        pass

    return None


def scoreboard_changed(old_data: List[Dict], new_data: List[Dict]) -> bool:
    """
    Determine if there's a meaningful difference between old and new scoreboard data.
    This function prevents unnecessary broadcasts when the data hasn't changed.

    Args:
        old_data: Previous scoreboard data
        new_data: Current scoreboard data

    Returns:
        True if there are meaningful changes, False otherwise
    """
    if not old_data and not new_data:
        return False

    if len(old_data) != len(new_data):
        return True

    # Create a map of old games by game_id for faster comparison
    old_map = {g["game_id"]: g for g in old_data}

    # Check each new game for changes
    for new_game in new_data:
        game_id = new_game["game_id"]
        if game_id not in old_map:
            # New game added
            return True

        old_game = old_map[game_id]

        # Check key fields for changes
        if (
            old_game["game_status"] != new_game["game_status"]
            or old_game["period"] != new_game["period"]
            or old_game["clock"] != new_game["clock"]
            or old_game["home_team"]["score"] != new_game["home_team"]["score"]
            or old_game["away_team"]["score"] != new_game["away_team"]["score"]
        ):
            return True

    return False


class ScoreboardManager:
    """Manages live scoreboard data and WebSocket connections."""

    def __init__(self):
        self.active_connections: Set[WebSocket] = set()
        self.current_games: List[Dict] = []  # Store current game state
        self._lock = asyncio.Lock()  # Add lock for thread safety
        self.last_update_timestamp: Dict[str, float] = (
            {}
        )  # Track last update time per game

    async def connect(self, websocket: WebSocket):
        """Add a new WebSocket connection."""
        await websocket.accept()
        self.active_connections.add(websocket)

    async def disconnect(self, websocket: WebSocket):
        """Remove a WebSocket connection."""
        self.active_connections.discard(websocket)

    def is_newer_data(self, game_id: str, new_data: Dict) -> bool:
        """
        Check if the new game data is actually newer than what we have.

        This prevents old/cached data from being considered as new updates.

        Args:
            game_id: The unique identifier for the game
            new_data: The new game data to check

        Returns:
            True if data is newer or we don't have previous data, False otherwise
        """
        current_time = time.time()

        # If we haven't seen this game before, it's definitely new
        if game_id not in self.last_update_timestamp:
            self.last_update_timestamp[game_id] = current_time
            return True

        # Check if data is actually newer based on game state
        old_game = next(
            (g for g in self.current_games if g["game_id"] == game_id), None
        )

        if not old_game:
            # If game wasn't in our current games, consider it new
            self.last_update_timestamp[game_id] = current_time
            return True

        # Check for state progression that indicates newer data
        is_newer = False

        # Game status progression (1->2->3 is expected)
        if new_data["game_status"] > old_game["game_status"]:
            is_newer = True
        # Period progression
        elif new_data["period"] > old_game["period"]:
            is_newer = True
        # Score changes (they should only increase)
        elif (
            new_data["home_team"]["score"] > old_game["home_team"]["score"]
            or new_data["away_team"]["score"] > old_game["away_team"]["score"]
        ):
            is_newer = True
        # For in-progress games, check clock progression (more complex)
        elif new_data["game_status"] == 2 and old_game["game_status"] == 2:
            # This would require parse_game_clock helper which we'll add below
            old_seconds = parse_game_clock(old_game["clock"])
            new_seconds = parse_game_clock(new_data["clock"])

            # Only if we can parse both clocks and new is less than old (counting down)
            if old_seconds is not None and new_seconds is not None:
                is_newer = new_seconds < old_seconds

        # Enforce a minimum time between updates for the same game
        # This prevents rapid flipping between states due to API inconsistency
        time_since_last_update = current_time - self.last_update_timestamp.get(
            game_id, 0
        )
        if (
            is_newer or time_since_last_update >= 5.0
        ):  # 5 seconds minimum between updates
            self.last_update_timestamp[game_id] = current_time
            return True

        return False

    def scoreboard_changed_with_timestamp_check(
        self, old_data: List[Dict], new_data: List[Dict]
    ) -> bool:
        """
        Enhanced version of scoreboard_changed that incorporates timestamp validation.

        Args:
            old_data: Previous scoreboard data
            new_data: Current scoreboard data

        Returns:
            True if there are meaningful changes with newer data, False otherwise
        """
        if not old_data and not new_data:
            return False

        if len(old_data) != len(new_data):
            return True

        has_changes = False

        # Create a map of old games by game_id for faster comparison
        old_map = {g["game_id"]: g for g in old_data}

        # Check each new game for changes
        for new_game in new_data:
            game_id = new_game["game_id"]

            # Always consider new games as changes
            if game_id not in old_map:
                has_changes = True
                continue

            old_game = old_map[game_id]

            # Check if key fields have changed
            has_game_changes = (
                old_game["game_status"] != new_game["game_status"]
                or old_game["period"] != new_game["period"]
                or old_game["clock"] != new_game["clock"]
                or old_game["home_team"]["score"] != new_game["home_team"]["score"]
                or old_game["away_team"]["score"] != new_game["away_team"]["score"]
            )

            # Only count changes if the data is actually newer
            if has_game_changes and self.is_newer_data(game_id, new_game):
                has_changes = True

        return has_changes

    async def broadcast(self, data: List[Dict]) -> bool:
        """
        Broadcast data to all connected clients, but only if it has changed,
        is newer than our current data, and has properly formatted clocks.

        Args:
            data: New scoreboard data

        Returns:
            True if data was broadcast, False otherwise
        """
        if not data:
            return False

        # Standardize game clocks first
        standardized_data = standardize_game_clocks(data)

        # Check if data has changed and is newer before broadcasting
        async with self._lock:
            # Use the enhanced change detection with timestamp validation
            if not self.scoreboard_changed_with_timestamp_check(
                self.current_games, standardized_data
            ):
                # No meaningful changes or data is stale, skip broadcasting
                return False

            # Update current games with standardized data
            self.current_games = copy.deepcopy(standardized_data)

        # Convert any datetime objects to strings
        json_data = json.loads(
            json.dumps(standardized_data, default=self._serialize_datetime)
        )

        # Broadcast to all connections
        for connection in self.active_connections.copy():
            try:
                await connection.send_json(json_data)
            except Exception as e:
                logger.error(f"Error broadcasting to client: {e}")
                await self.disconnect(connection)

        return True

    async def send_current_games(self, websocket: WebSocket):
        """Send initial scoreboard data to a new connection."""
        try:
            current_games = await get_live_scoreboard()

            # Convert the Pydantic model to a dict
            games_data = current_games.model_dump()

            # Standardize game clocks
            standardized_data = standardize_game_clocks(games_data["games"])

            # Ensure all datetime objects are converted to strings
            json_data = json.loads(
                json.dumps(standardized_data, default=self._serialize_datetime)
            )

            # Send standardized games data
            await websocket.send_json(json_data)
        except Exception as e:
            logger.error(f"Error sending initial games data: {e}")
            raise

    def _serialize_datetime(self, obj):
        """Helper method to serialize datetime objects to ISO format."""
        if isinstance(obj, datetime):
            return obj.isoformat()
        raise TypeError(f"Type {type(obj)} not serializable")


class PlayByPlayManager:
    """Manages play-by-play WebSocket connections for individual games."""

    def __init__(self):
        self.active_connections: Dict[str, Set[WebSocket]] = {}
        self.last_data: Dict[str, Any] = {}
        self.tasks: Dict[str, asyncio.Task] = {}
        self._lock = asyncio.Lock()  # Added lock for concurrency safety

    async def connect(self, websocket: WebSocket, game_id: str):
        """Add a new WebSocket connection for a specific game and start background polling if needed."""
        await websocket.accept()
        async with self._lock:
            if game_id not in self.active_connections:
                self.active_connections[game_id] = set()
            self.active_connections[game_id].add(websocket)
            if game_id not in self.tasks:
                self.tasks[game_id] = asyncio.create_task(
                    self._poll_playbyplay(game_id)
                )

    async def disconnect(self, websocket: WebSocket, game_id: str):
        """Remove a WebSocket connection for a specific game."""
        async with self._lock:
            if game_id in self.active_connections:
                self.active_connections[game_id].discard(websocket)
                if not self.active_connections[game_id]:
                    if game_id in self.tasks:
                        self.tasks[game_id].cancel()
                        del self.tasks[game_id]
                    del self.active_connections[game_id]
                    if game_id in self.last_data:
                        del self.last_data[game_id]

    async def broadcast_to_game(self, game_id: str, data: Any):
        """Broadcast data to all connections for a specific game."""
        async with self._lock:
            if game_id not in self.active_connections:
                return
            connections = self.active_connections[game_id].copy()
        for connection in connections:
            try:
                await connection.send_json(data)
            except Exception as e:
                logger.error(f"Error broadcasting to game {game_id} client: {e}")
                await self.disconnect(connection, game_id)

    async def _poll_playbyplay(self, game_id: str):
        from nba_api.live.nba.endpoints import playbyplay  # typically imported here

        logger.info(f"Starting PlayByPlay polling for {game_id}")
        while True:
            try:
                p = playbyplay.PlayByPlay(game_id)
                if not p:
                    await asyncio.sleep(0.2)
                    continue

                current_data = p.get_dict()
                # Fallback: if current_data is empty or missing a nonempty "plays" key and p has a "games" attribute, try that
                if (not current_data or not current_data.get("plays")) and hasattr(
                    p, "games"
                ):
                    logger.debug(
                        "No plays found using p.get_dict(); trying p.games.get_dict()"
                    )
                    current_data = p.games.get_dict()

                last = self.last_data.get(game_id)
                if not last or (last != current_data):
                    self.last_data[game_id] = current_data
                    await self.broadcast_to_game(
                        game_id, current_data
                    )  # Updated method call
                await asyncio.sleep(0.2)
            except asyncio.CancelledError:
                logger.info(f"Canceling PlayByPlay polling for {game_id}")
                break
            except Exception as e:
                logger.error(f"[PlayByPlay] Error in background loop ({game_id}): {e}")
                await asyncio.sleep(1)


# Helper functions for data processing


async def get_live_scoreboard() -> ScoreboardResponse:
    """
    Fetch current scoreboard data from NBA API.
    Returns:
        ScoreboardResponse containing current games
    """
    try:
        board = scoreboard.ScoreBoard()
        games_data = board.games.get_dict()
        games = []

        for game in games_data:
            # Create TeamGameInfo objects with string IDs
            home_team = TeamGameInfo(
                team_id=str(game["homeTeam"]["teamId"]),  # Convert to string
                team_name=game["homeTeam"]["teamName"],
                team_city=game["homeTeam"]["teamCity"],
                team_tricode=game["homeTeam"]["teamTricode"],
                score=game["homeTeam"].get("score", 0),
            )

            away_team = TeamGameInfo(
                team_id=str(game["awayTeam"]["teamId"]),  # Convert to string
                team_name=game["awayTeam"]["teamName"],
                team_city=game["awayTeam"]["teamCity"],
                team_tricode=game["awayTeam"]["teamTricode"],
                score=game["awayTeam"].get("score", 0),
            )

            # Create GameBrief object
            game_brief = GameBrief(
                game_id=str(game["gameId"]),  # Convert to string
                game_status=game["gameStatus"],
                period=game.get("period", 0),
                clock=game.get("gameClock"),
                game_time=parser.parse(game["gameTimeUTC"]),
                home_team=home_team,
                away_team=away_team,
            )

            games.append(game_brief)

        return ScoreboardResponse(games=games, total_games=len(games))

    except Exception as e:
        logger.error(f"Error fetching live scoreboard: {e}")
        raise


async def get_past_scoreboard(date_str: str) -> List[GameBrief]:
    """
    Get scoreboard data for a past date.
    Args:
        date_str: Date in YYYY-MM-DD format
    Returns:
        List of games for the specified date
    """
    try:
        from nba_api.stats.endpoints import leaguegamefinder

        date_obj = datetime.strptime(date_str, "%Y-%m-%d")
        date_formatted = date_obj.strftime("%m/%d/%Y")
        games_df = leaguegamefinder.LeagueGameFinder(
            date_from_nullable=date_formatted,
            date_to_nullable=date_formatted,
            league_id_nullable="00",
        ).get_data_frames()[0]
        return process_past_games(games_df)
    except Exception as e:
        logger.error(f"Error fetching past scoreboard: {e}")
        raise


# Updated get_box_score function in app/services/scoreboard.py


async def get_box_score(game_id: str) -> GameBoxScore:
    """
    Get detailed box score for a specific game.
    Args:
        game_id: NBA game ID
    Returns:
        GameBoxScore with detailed statistics
    Raises:
        Exception if box score cannot be retrieved
    """
    try:
        box = boxscore.BoxScore(game_id)

        # Debug logging to see the raw data structure
        raw_data = box.get_dict()
        logger.debug(f"Raw boxscore data for game {game_id}: {raw_data}")

        # Access the proper data structure
        # Note: Depending on the actual structure, we might need to adjust this
        # If get_dict() doesn't return the expected structure, try alternative paths

        # Option 1: Direct structure from get_dict()
        boxscore_data = raw_data

        # Option 2: If data is nested under a specific key
        # boxscore_data = raw_data.get('game', {})  # Adjust based on actual structure

        # Process the boxscore data
        return process_box_score(boxscore_data)
    except Exception as e:
        logger.error(f"Error fetching box score for game {game_id}: {e}")
        # Re-raise as HTTP exception or return a default/empty response
        raise


async def get_play_by_play(game_id: str) -> PlayByPlayResponse:
    """
    Get play-by-play data for a specific game.
    Args:
        game_id: NBA game ID
    Returns:
        PlayByPlayResponse with play-by-play events
    """
    try:
        pbp = playbyplay.PlayByPlay(game_id)
        return process_play_by_play(pbp.get_dict())
    except Exception as e:
        logger.error(f"Error fetching play-by-play for game {game_id}: {e}")
        raise


def process_past_games(games_df) -> List[GameBrief]:
    """
    Process games DataFrame into GameBrief objects.
    Args:
        games_df: DataFrame from NBA API containing game data
    Returns:
        List of GameBrief objects
    """
    games = []
    grouped = games_df.groupby("GAME_ID")
    for game_id, group in grouped:
        try:
            away_row = group[group["MATCHUP"].str.contains("@")].iloc[0]
            home_row = group[group["MATCHUP"].str.contains("vs.")].iloc[0]
        except IndexError:
            continue
        away_team = TeamGameInfo(
            team_id=str(away_row["TEAM_ID"]),
            team_name=away_row["TEAM_NAME"],
            team_city="",  # Placeholder as TEAM_CITY is not provided
            team_tricode=away_row["TEAM_ABBREVIATION"],
            score=int(away_row["PTS"]),
        )
        home_team = TeamGameInfo(
            team_id=str(home_row["TEAM_ID"]),
            team_name=home_row["TEAM_NAME"],
            team_city="",
            team_tricode=home_row["TEAM_ABBREVIATION"],
            score=int(home_row["PTS"]),
        )
        game_brief = GameBrief(
            game_id=str(game_id),
            game_status=3,  # Past games are final
            period=4,
            clock="Final",
            game_time=parser.parse(home_row["GAME_DATE"]),
            home_team=home_team,
            away_team=away_team,
        )
        games.append(game_brief)
    return games


def process_box_score(box_score_data: Dict) -> GameBoxScore:
    """
    Process box score data into GameBoxScore object.
    Args:
        box_score_data: Dictionary containing box score data from NBA API
    Returns:
        GameBoxScore object with detailed statistics
    """

    def process_team(team_data: Dict) -> TeamBoxScore:
        players = []
        for player in team_data.get("players", []):
            stats = player.get("statistics", {})
            player_stats = PlayerStatistics(
                minutes=stats.get("minutes", "0:00"),
                points=stats.get("points", 0),
                assists=stats.get("assists", 0),
                rebounds=stats.get("reboundsTotal", 0),
                field_goals_made=stats.get("fieldGoalsMade", 0),
                field_goals_attempted=stats.get("fieldGoalsAttempted", 0),
                field_goal_percentage=stats.get("fieldGoalsPercentage", 0.0),
                three_pointers_made=stats.get("threePointersMade", 0),
                three_pointers_attempted=stats.get("threePointersAttempted", 0),
                three_point_percentage=stats.get("threePointersPercentage", 0.0),
                free_throws_made=stats.get("freeThrowsMade", 0),
                free_throws_attempted=stats.get("freeThrowsAttempted", 0),
                free_throw_percentage=stats.get("freeThrowsPercentage", 0.0),
                plus_minus=stats.get("plusMinusPoints", 0),
            )
            player_box = PlayerBoxScore(
                player_id=str(player.get("personId", "")),
                name=player.get("name", ""),
                position=player.get("position", ""),
                starter=player.get("starter", False),
                statistics=player_stats,
            )
            players.append(player_box)

        # Ensure team_id is converted to string
        team_id = team_data.get("teamId", "")
        if team_id != "":
            team_id = str(team_id)

        return TeamBoxScore(
            team_id=team_id,
            team_name=team_data.get("teamName", ""),
            team_city=team_data.get("teamCity", ""),
            team_tricode=team_data.get("teamTricode", ""),
            players=players,
        )

    game_id = box_score_data.get("gameId", "")
    if game_id:
        game_id = str(game_id)

    home_team = process_team(box_score_data.get("homeTeam", {}))
    away_team = process_team(box_score_data.get("awayTeam", {}))

    return GameBoxScore(
        game_id=game_id,
        status=box_score_data.get("gameStatus", 1),
        period=box_score_data.get("period", 0),
        clock=box_score_data.get("gameClock"),
        home_team=home_team,
        away_team=away_team,
    )


def process_play_by_play(pbp_data: Dict) -> PlayByPlayResponse:
    """
    Process play-by-play data into PlayByPlayResponse object.
    Args:
        pbp_data: Dictionary containing play-by-play data from NBA API
    Returns:
        PlayByPlayResponse with play-by-play events
    """
    events = []
    for play in pbp_data.get("plays", []):
        event = PlayByPlayEvent(
            event_id=str(play.get("eventId", "")),
            clock=play.get("clock", ""),
            period=play.get("period", 0),
            description=play.get("description", ""),
            score=play.get("scoreDisplay"),
            team_tricode=play.get("teamTricode"),
            player_name=play.get("playerNameI"),
        )
        events.append(event)
    return PlayByPlayResponse(
        game_id=str(pbp_data.get("gameId", "")),
        period=pbp_data.get("period", 0),
        clock=pbp_data.get("gameClock"),
        events=events,
    )


# Global instances of managers
scoreboard_manager = ScoreboardManager()
playbyplay_manager = PlayByPlayManager()


================================================
File: nba_scoreboard_api/api/app/services/standings.py
================================================
# app/services/standings.py
import logging
from sqlalchemy.orm import Session
from sqlalchemy import func
from nba_api.stats.endpoints import leaguestandings
from typing import List

from app.models.standings import TeamStanding
from app.schemas.standings import StandingsResponse

# Configure logging
logger = logging.getLogger(__name__)

async def update_standings_database(db: Session) -> None:
    """
    Update the standings in the database with current NBA standings.
    
    Args:
        db: Database session
    
    Raises:
        Exception: If there's an error updating the database
    """
    try:
        # Get current standings
        standings = leaguestandings.LeagueStandings(season='2024-25')
        df = standings.standings.get_data_frame()
        
        try:
            # Clear existing standings
            db.query(TeamStanding).delete()
            
            # Add new standings
            for _, row in df.iterrows():
                db_standing = TeamStanding(
                    team_id=row['TeamID'],
                    team_city=row['TeamCity'],
                    team_name=row['TeamName'],
                    conference=row['Conference'],
                    division=row['Division'],
                    wins=row['WINS'],
                    losses=row['LOSSES'],
                    win_pct=row['WinPCT'],
                    games_back=row['ConferenceGamesBack'],
                    conference_rank=row['PlayoffRank'],
                    division_rank=row['DivisionRank'],
                    home_record=row['HOME'],
                    road_record=row['ROAD'],
                    last_ten=row['L10'],
                    streak=row['CurrentStreak'],
                    points_pg=row['PointsPG'],
                    opp_points_pg=row['OppPointsPG'],
                    division_record=row['DivisionRecord'],
                    conference_record=row['ConferenceRecord'],
                    vs_east=f"{row['vsEast']}",
                    vs_west=f"{row['vsWest']}"
                )
                db.add(db_standing)
            
            db.commit()
            logger.info("Successfully updated standings database")
            
        except Exception as e:
            db.rollback()
            logger.error(f"Error updating standings database: {e}")
            raise
            
    except Exception as e:
        logger.error(f"Error fetching standings data: {e}")
        raise

async def get_conference_standings(
    db: Session,
    conference: str
) -> List[StandingsResponse]:
    """
    Get standings for a specific conference.
    
    Args:
        db: Database session
        conference: Conference name ('East' or 'West')
    
    Returns:
        List of team standings for the specified conference
    """
    standings = (
        db.query(TeamStanding)
        .filter(func.lower(TeamStanding.conference) == func.lower(conference))
        .order_by(TeamStanding.conference_rank)
        .all()
    )
    return standings

async def get_division_standings(
    db: Session,
    division: str
) -> List[StandingsResponse]:
    """
    Get standings for a specific division.
    
    Args:
        db: Database session
        division: Division name
    
    Returns:
        List of team standings for the specified division
    """
    standings = (
        db.query(TeamStanding)
        .filter(func.lower(TeamStanding.division) == func.lower(division))
        .order_by(TeamStanding.division_rank)
        .all()
    )
    return standings

def validate_conference(conference: str) -> bool:
    """
    Validate conference name.
    
    Args:
        conference: Conference name to validate
    
    Returns:
        True if valid, False otherwise
    """
    return conference.lower() in ['east', 'west']

def validate_division(division: str) -> bool:
    """
    Validate division name.
    
    Args:
        division: Division name to validate
    
    Returns:
        True if valid, False otherwise
    """
    valid_divisions = [
        'atlantic',
        'central',
        'southeast',
        'northwest',
        'pacific',
        'southwest'
    ]
    return division.lower() in valid_divisions

